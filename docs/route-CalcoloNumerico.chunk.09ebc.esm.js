(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{"2w3n":function(l){l.exports={red:"red__2y1B_",orange:"orange__dD2kx",yellow:"yellow__OEpwl",lime:"lime__CVe41",cyan:"cyan__26ZAg",blue:"blue__LO7Xm",magenta:"magenta__1Akee",example:"example__2PzAa"}},"31Ft":function(l,n,i){"use strict";(function(l){i("4UPQ");var e=i("hosL"),o=i("mbOI"),a=i("ke5e");let t,r,u,s,p,c,d,m,h,_,f,g,b,z,x,v,q,k,L,A,y,S,w,C,O,I,G,R=l=>l;const M=String.raw;n.a=function(){return l(e.Fragment,null,l(o.r,{title:"Problema: Interpolazione"},l(o.q,{title:"Descrizione"},l("p",null,"Si vuole trovare una funzione in grado di ",l("b",null,"approssimarne")," un'altra, di cui si conoscono però solo alcuni punti."),l(a.a,null,"È utile in un sacco di casi! Ad esempio, quando si vuole scalare un'immagine."),l("p",null,"I punti sono detti ",l("b",null,"nodi")," ",l(o.h,null,M(t||(t=R`(x_i, y_i)`))),", mentre la funzione costruita su di essi è detta ",l("b",null,"interpolante")," ",l(o.h,null,M(r||(r=R`g`))),":"),l(o.p,null,M(u||(u=R`g(x_i) = y_i`))),l("p",null,"Dato un insieme di punti, esistono ",l("b",null,"infinite")," funzioni interpolanti.")),l(o.q,{title:"Interpolazione polinomiale"},l("p",null,"Il ",l("u",null,"teorema fondamentale dell'algebra")," dice che ",l("b",null,"esiste una sola interpolante ",l("i",null,"polinomiale"))," che interpola un dato insieme di punti."),l("p",null,"Con ",l(o.h,null,"n+1")," punti, l'interpolante sarà al massimo di grado ",l(o.h,null,"n"),", e viene detta ",l(o.h,null,M(s||(s=R`p_n`))),"."),l("p",null,"La sua ",l("b",null,"forma canonica")," sarà:"),l(o.p,null,M(p||(p=R`p_n(x) = a_0 + a_1 x + a_2 x^2 + a_3 x^3 + \dots + a_n x^n`))))),l(o.r,{title:"Metodi di interpolazione"},l(o.q,{title:"Metodo dei coefficienti indeterminati"},l("p",null,"È possibile scrivere la forma canonica come ",l("b",null,"matrice"),":"),l(o.p,null,M(c||(c=R`A \cdot x = b`))),l("p",null,"Costruiamo la ",l("b",null,"matrice di Vandermonde"),":"),l(o.p,null,M(d||(d=R`
                    A =
                    \begin{pmatrix}
                        1 & x_0 & x_0^2 & \dots & x_0^n\\\\
                        1 & x_1 & x_1^2 & \dots & x_1^n\\\\
                        1 & x_2 & x_2^2 & \dots & x_2^n\\\\
                        \vdots & \vdots & \vdots & \ddots & \vdots\\\\
                        1 & x_n & x_n^2 & \dots & x_n^n
                    \end{pmatrix}
                    `))),l("p",null,"Costruiamo il ",l("b",null,"vettore delle incognite"),":"),l(o.p,null,M(m||(m=R`
                    x = 
                    \begin{pmatrix}
                        a_0\\\\
                        a_1\\\\
                        a_2\\\\
                        \vdots\\\\
                        a_n
                    \end{pmatrix}
                    `))),l("p",null,"Costruiamo il ",l("b",null,"vettore dei termini noti"),":"),l(o.p,null,M(h||(h=R`
                    b =
                    \begin{pmatrix}
                        y_0\\\\
                        y_1\\\\
                        y_2\\\\
                        \vdots\\\\
                        y_n
                    \end{pmatrix}
                    `))),l(a.a,null,"Per trovare il polinomio di interpolazione è sufficiente risolvere il problema!"),l("p",null,"È efficace perchè una volta calcolati i coefficienti essi ",l("b",null,"valgono per tutti i punti"),", ma ha come svantaggio che la matrice di Vandermonde è ",l("b",null,"spesso malcondizionata."))),l(o.q,{title:"Metodo di Lagrange"},l("p",null,"È possibile scrivere il polinomio di interpolazione ",l("b",null,"raccogliendo le ",l(o.h,null,M(_||(_=R`y`)))),":"),l(o.p,null,M(f||(f=R`p_n (x) = y_0 L_0 + y_1 L_1 + y_2 L_2 + \dots + y_n L_n`))),l("p",null,"I polinomi ",l(o.h,null,M(g||(g=R`L_k`)))," sono detti ",l("b",null,"polinomi di Lagrange"),", e hanno le seguenti proprietà:"),l("ul",null,l("li",null,"Valgono ",l(o.h,null,"1")," in corrispondenza del nodo con lo stesso indice, ",l(o.h,null,"0")," in corrispondenza dei nodi con indice diverso e ",l(o.h,null,M(b||(b=R`0 < n < 1`)))," in tutti gli altri casi.",l(o.p,null,M(z||(z=R`
                            \begin{cases}
                                L_k(x_k) = 1 \qquad (nel\ nodo)\\
                                L_k(x_j) = 0 \qquad (altri\ nodi)
                            \end{cases}
                        `)))),l("li",null,"Si compongono con questo prodotto:",l(o.p,null,M(x||(x=R`L_k = \frac{(x - x_0) \cdot \dots \cdot (x - x_{k-1}) \cdot (x - x_{k+1}) \cdot \dots \cdot (x_k - x_n)}{(x_k - x_0) \cdot \dots \cdot (x_k - x_{k-1}) \cdot (x_k - x_{k+1}) \cdot \dots \cdot (x_k - x_n)}`))))),l(a.a,null,"Non c'è il termine con ",l(o.h,null,M(v||(v=R`x_k`))),"!"),l("p",null,"Tutti insieme formano la ",l("b",null,"base di Lagrange"),"."),l(a.a,null,"Si chiama base perchè sono ",l("b",null,"linearmente indipendenti"),"!"),l("p",null,"Questo metodo permette di calcolare il valore del polinomio di interpolazione ",l("b",null,"in un singolo punto"),":"),l(a.a,null,l("p",null,"Si può risparmiare tempo di calcolo calcolando una singola volta il numeratore con ",l("i",null,"tutti")," i termini:"),l(o.p,null,M(q||(q=R`\omega_n = (x - x_0) \cdot (x - x_1) \cdot \dots \cdot (x - x_n)`))),l("p",null,"E poi dividendo per il termine che andrebbe escluso:"),l(o.p,null,M(k||(k=R`L_k(x) = \frac{ \omega_n }{ (x - x_k) \cdot \prod_{i=0, i \neq k} (x_k - x_i) }`)))),l("p",null,"Ha costo computazionale ",l(o.h,null,M(L||(L=R`O(n^2)`))),"."))),l(o.r,{title:"Resto di interpolazione"},l(o.q,{title:"Definizione"},l("p",null,"È l'",l("b",null,"errore compiuto durante l'interpolazione"),"."),l("p",null,"Se la funzione ",l(o.h,null,"f")," è interpolata da ",l(o.h,null,"p_n"),", allora esso varrà:"),l(o.p,null,M(A||(A=R`R_n(x) = f(x) - p_n(x)`))),l("p",null,"In particolare, è interessante la sua norma a infinito, ",l(o.h,null,M(y||(y=R`\| f - p_n \|_\infty`))),", che corrisponde alla distanza massima tra le due funzioni."),l("p",null,"Un teorema dice che esso è uguale a: ",l(o.u,null,"TODO: Non credo serva.")),l(o.p,null,M(S||(S=R`R_n(x) = \frac{ \omega_n(x) }{ (n + 1)! } \cdot f^{(n+1)}(\Xi)`)))),l(o.q,{title:"Stima"},l("p",null,l(o.u,null,"TODO: Tutta la dimostrazione di queste due affermazioni.")),l("p",null,"L'errore nell'interpolazione dipende principalmente da due fattori:"),l("ul",null,l("li",null,"Come sono ",l("b",null,"distribuiti sull'asse X")," i punti da interpolare"),l("li",null,"Il grado del polinomio di interpolazione")))),l(o.r,null,l(o.q,{title:"Fenomeno di Runge"},l("p",null,"Fenomeno che si verifica cercando di interpolare la ",l("i",null,"funzione di Runge")," (",l(o.h,null,M(w||(w=R`\frac{1}{1 + 25x^2}`))),")."),l("p",null,"Scegliendo ",l("b",null,"nodi equispaziati"),", l'errore di interpolazione sarà ",l("b",null,"enorme")," vicino ai due estremi dell'intervallo."),l(a.a,null,"Addirittura, più nodi verranno scelti, più esso sarà alto!"),l("p",null,"Si evita scegliendo i nodi in una maniera diversa.")),l(o.q,{title:"Nodi di Chebychev"},l("p",null,"Nodi ottenuti partizionando una ",l("b",null,"semicirconferenza"),", e proiettando le partizioni sul diametro."),l("p",null,"La formula usata per ottenere ",l(o.h,null,M(C||(C=R`n`)))," punti è:"),l(o.p,null,M(O||(O=R`x_i = \cos \left( \frac{ (2 \cdot i + 1) \cdot \pi }{ 2 \cdot (n+1) } \right)`))),l("p",null,l("u",null,"Proprietà di min-max"),": sono la ",l("b",null,"scelta ottimale")," dei punti di interpolazione."),l(o.p,null,M(I||(I=R`\omega_n(\star) = \max_{x \in [a, b]} \left| \omega_n(x) \right|`))),l("p",null,"In particolare, si ha che:"),l(o.p,null,M(G||(G=R`\omega_n(\star) = 2 \left( \frac{b-a}{4} \right)^{n+1}`))))))}}).call(this,i("hosL").h)},"4UPQ":function(){},"5aVd":function(l){l.exports={menulist:"menulist__2Cmnq"}},FEtp:function(l,n,i){"use strict";(function(l){i("h/TB");var e=i("hosL"),o=i("mbOI"),a=i("ke5e");let t,r,u,s,p,c,d,m,h,_,f,g,b,z,x,v,q,k,L,A,y,S,w,C,O,I,G,R,M,T,P,F,E,Q,D,N,U,Y,H,j,V,J,X,B,Z,K,W,$,ll,nl,il,el,ol,al,tl,rl,ul,sl,pl=l=>l;const cl=String.raw;n.a=function(){return l(e.Fragment,null,l(o.r,{title:"Problema: Ricerca degli zeri di funzione"},l(o.q,{title:"Descrizione"},l("p",null,"Si vogliono trovare i punti (",l("i",null,"zeri"),") in cui una funzione ",l("b",null,"continua")," ",l(o.h,null,"f : [a, b] \\to R")," vale ",l(o.h,null,"0"),"."),l("p",null,"Per il ",l("b",null,"teorema del valore medio"),", se ",l(o.h,null,cl(t||(t=pl`f(a) \cdot f(b) \leq 0`))),", allora esiste sicuramente un punto in cui la funzione vale 0."),l("p",null,"Denominiamo il punto in cui la funzione vale ",l(o.h,null,"0")," come ",l(o.h,null,cl(r||(r=pl`x_{(\star)}`))),".")),l(o.q,{title:"Condizionamento"},l("p",null,"Più la ",l("b",null,"derivata prima")," della funzione ",l("b",null,"si avvicina allo 0"),", ",l("b",null,"peggio")," il problema sarà condizionato."),l(o.p,null,cl(u||(u=pl`f'(x_{(\star)}) \simeq 0 \implies mal\ condizionato`))))),l(o.r,null,l(o.q,{title:"Ordine di convergenza"},l("p",null,"Indice ",l(o.h,null,cl(s||(s=pl`{\color{Orange} p}`)))," di quanto in fretta una successione converge alla soluzione."),l(o.p,null,cl(p||(p=pl`\lim_{i \to +\infty} \frac{ \left| x_{(i+1)} - x_{(\star)} \right| }{ \left| x_{(k)} - x_{(\star)} \right|^{\color{Orange} p}}`))),l("ul",null,l("li",null,l("u",null,"Convergenza lineare"),": ",l(o.h,null,cl(c||(c=pl`p = 1`)))," e ",l(o.h,null,cl(d||(d=pl`0 < C < 1`)))),l("li",null,l("u",null,"Convergenza superlineare"),": ",l(o.h,null,cl(m||(m=pl`p = 1`)))," e ",l(o.h,null,cl(h||(h=pl`C = 0`)))),l("li",null,l("u",null,"Convergenza quadratica"),": ",l(o.h,null,cl(_||(_=pl`p = 2`)))," e ",l(o.h,null,cl(f||(f=pl`0 < C < 1`)))),l("li",null,l("u",null,"Convergenza superquadratica"),": ",l(o.h,null,cl(g||(g=pl`p = 2`)))," e ",l(o.h,null,cl(b||(b=pl`C = 0`)))),l("li",null,"...")))),l(o.r,{title:"Metodi dicotomici"},l(o.q,{title:"Cosa sono?"},l("p",null,"Sono ",l("b",null,"metodi iterativi")," in grado di ridurre sempre di più l'intervallo in cui è definita la funzione, facendolo convergere allo zero desiderato."),l("p",null,"Alcuni di essi sono il ",l("i",null,"metodo dicotomico")," e il ",l("i",null,"metodo regula falsi"),"."),l("p",null,"Richiedono ",l("b",null,"una valutazione di funzione non-lineare")," ad ogni iterazione."),l("p",null,"Ad ogni iterazione, l'intervallo viene sempre ",l("i",null,"almeno")," ",l("b",null,"dimezzato"),"; si ha, pertanto, che:"),l(o.p,null,cl(z||(z=pl`b_{(i)} - a_{(i)} = \frac{b - a}{2^{i - 1}}`))),l("p",null,"Hanno quindi ",l("b",null,"convergenza lineare")," (",l(o.h,null,cl(x||(x=pl`C = \frac{1}{2}, p = 1`))),")."),l("p",null,"Il loro ",l("i",null,"criterio di arresto")," è un ",l("b",null,"numero di iterazioni prefissato")," che dipende dalla ",l("b",null,"tolleranza")," sull'errore:"),l(o.p,null,cl(v||(v=pl`i \geq \log_2 \left( \frac{b - a}{\tau} \right)`))),l(a.a,null,"Dividi l'intervallo ",l(o.h,null,cl(q||(q=pl`[a, b]`)))," in tante parti grandi quanto la tolleranza. L'algoritmo di bisezione ne escluderà metà ad ogni iterazione; la tolleranza sarà raggiunta quando rimarrà una parte sola!"))),l(o.r,null,l(o.q,{title:"Metodo di bisezione"},l("ol",null,l("li",null,"Finchè non sono state compiute il numero di iterazioni prefissate:",l("ol",null,l("li",null,"Calcoliamo il ",l("b",null,"punto medio")," dell'intervallo ",l(o.h,null,cl(k||(k=pl`[a_{(n)}, b_{(n)}]`))),":",l(o.p,null,cl(L||(L=pl`c_{(n)} = a_{(n)} + \frac{b_{(n)} - a_{(n)}}{2}`)))),l("li",null,"Dividiamo l'intervallo in due parti, separate da ",l(o.h,null,cl(A||(A=pl`c_{(n)}`))),":",l("ul",null,l("li",null,l(o.h,null,cl(y||(y=pl`[a_{(n)}, c_{(n)}]`)))," è la ",l("b",null,"metà")," sinistra"),l("li",null,l(o.h,null,cl(S||(S=pl`[c_{(n)}, b_{(n)}]`)))," è la ",l("b",null,"metà")," destra"))),l("li",null,"Teniamo l'intervallo in cui i valori della funzione ai due estremi sono discordi, e rinominiamolo in ",l(o.h,null,cl(w||(w=pl`[a_{(n+1)}, b_{(n+1)}]`))),"."))))),l(o.q,{title:"Metodo regula falsi"},l("ol",null,l("li",null,"Finchè non sono state compiute il numero di iterazioni prefissate:",l("ol",null,l("li",null,"Calcoliamo l'",l("b",null,"intersezione")," tra la ",l("b",null,"retta che congiunge i due estremi")," ",l(o.h,null,cl(C||(C=pl`a_{(n)}, b_{(n)}`)))," e l'",l("b",null,"asse X"),":",l(o.p,null,cl(O||(O=pl`c_{(n)} = b_{(n)} - \frac{f(b_{(n)})}{\frac{f(b_{(n)}) - f(a_{(n)})}{b_{(n)} - a_{(n)}}}`)))),l("li",null,"Dividiamo l'intervallo in due parti, separate da ",l(o.h,null,cl(I||(I=pl`c_{(n)}`))),":",l("ul",null,l("li",null,l(o.h,null,cl(G||(G=pl`[a_{(n)}, c_{(n)}]`)))," è la parte sinistra"),l("li",null,l(o.h,null,cl(R||(R=pl`[c_{(n)}, b_{(n)}]`)))," è la parte destra"))),l("li",null,"Teniamo l'intervallo in cui i valori della funzione ai due estremi sono discordi, e rinominiamolo in ",l(o.h,null,cl(M||(M=pl`[a_{(n+1)}, b_{(n+1)}]`))),".")))))),l(o.r,{title:"Metodo delle approssimazioni successive"},l(o.q,{title:"Metodi delle approssimazioni successive"},l("p",null,"Sono ",l("b",null,"metodi iterativi")," che funzionano in modo molto simile ai metodi iterativi per i sistemi lineari, utilizzando una funzione ",l(o.h,null,cl(T||(T=pl`\phi`))),' come "metodo".'),l(o.p,null,cl(P||(P=pl`x = x - \phi(x) \cdot f(x)`))),l("p",null,"Che diventa:"),l(o.p,null,cl(F||(F=pl`x_{(k+1)} = g( x_{(k)} )`))),l("p",null,"Sfruttano i ",l("b",null,"punti fissi")," ",l(o.h,null,cl(E||(E=pl`g(x_{(\star)}) = x_{(\star)}`)))," della funzione ",l(o.h,null,cl(Q||(Q=pl`f`)))," per convergere:",l("br",null),"se ",l(o.h,null,cl(D||(D=pl`\phi(x)`)))," non ha zeri, allora i punti fissi ",l("b",null,"coincideranno")," con gli ",l("b",null,"zeri")," della funzione ",l(o.h,null,cl(N||(N=pl`f`))),"."),l(o.p,null,cl(U||(U=pl`g(x) = x - \phi(x) \cdot f(x)`))),l("p",null,"Si può raggiungere iterativamente ad un punto fisso attraverso la formula:"),l(o.p,null,cl(Y||(Y=pl`x_{(k+1)} = g( x_{(k)} )`))),l("p",null,"Non si conosce in anticipo il numero di iterazioni necessarie per soddisfare la tolleranza ",l(o.h,null,cl(H||(H=pl`\tau`))),"; ad ogni iterazione, si controlla se la tolleranza è soddisfatta:"),l("ul",null,l("li",null,"Nella differenza tra due iterate: ",l(o.h,null,cl(j||(j=pl`\frac{\left| x_{(k+1)} - x_{(k)} \right|}{\left| x_{(k+1)} \right|} \leq \tau`)))),l("li",null,"Nel ",l("i",null,"residuo")," del problema: ",l(o.h,null,cl(V||(V=pl`\left| f(x_{(k)}) \right| \leq \tau`)))))),l(o.q,{title:"Teorema della mappa contrattiva"},l("p",null,"Se:"),l("ul",null,l("li",null,"Tutti i valori restituiti dalla funzione ",l(o.h,null,cl(J||(J=pl`g`)))," rientrano nel suo stesso dominio:",l(o.p,null,cl(X||(X=pl`g : [a, b] \to [a, b]`)))),l("li",null,l("p",null,"La funzione ",l(o.h,null,cl(B||(B=pl`g`)))," è una contrazione, ovvero restringe l'intervallo ",l(o.h,null,cl(Z||(Z=pl`[a, b]`))),":"),l(o.p,null,cl(K||(K=pl`\forall (x, y) \in [a, b], | g(x) - g(y) | \leq L \cdot | x - y |`))),l("p",null,"(dove ",l(o.h,null,cl(W||(W=pl`0 < L < 1`))),")"))),l("p",null,"Allora:"),l("ul",null,l("li",null,l("p",null,"Il punto fisso esiste ed è unico:"),l(o.p,null,cl($||($=pl`\exists! x_{(\star)}`)))),l("li",null,"Il metodo delle approssimazioni successive converge per qualsiasi punto di partenza."),l("li",null,l("p",null,"Vale la seguente disequazione di ",l("i",null,"maggiorazione dell'errore"),":"),l(o.p,null,cl(ll||(ll=pl`\left| x_{(k)} - x_{(\star)} \right| \leq \frac{ L^k }{ 1 - L } \cdot \left| x_{(1)} - x_{(0)} \right|`))))),l("p",null,"Più è piccolo ",l(o.h,null,"L"),", più il metodo convergerà in fretta."),l(a.a,null,l(o.h,null,"L")," è molto simile al raggio spettrale ",l(o.h,null,cl(nl||(nl=pl`\rho(M)`)))," dei metodi iterativi per i sistemi lineari!"))),l(o.r,null,l(o.q,{title:"Metodo di Newton"},l("p",null,"Sfrutta la ",l("b",null,"continuità")," delle funzioni per ottenere una convergenza di ordine più alto."),l(o.p,null,cl(il||(il=pl`\phi (x) = \frac{1}{f' (x)}`))),l(o.p,null,cl(el||(el=pl`x_{(k+1)} = x_{(k)} - \frac{ f(x_{(k)}) }{ f'(x_{(k)}) }`))),l(a.a,null,"Geometricamente, corrisponde a prolungare una retta nel punto ",l(o.h,null,cl(ol||(ol=pl`(x_{(k)}, f(x_{(k)}))`)))," con pendenza ",l(o.h,null,cl(al||(al=pl`f'(x_{(k)})`))),", e prendendo come nuovo punto la sua intersezione con l'asse X e la sua corrispettiva immagine nella funzione."),l("p",null,"Ha costo computazionale di ",l("b",null,"2 valutazioni di funzione")," più ",l("b",null,"2 valutazioni di derivata"),"."),l("p",null,"Ha ",l("b",null,"convergenza quadratica"),".")),l(o.q,{title:"Metodo delle secanti"},l("p",null,"È come il metodo di Newton, ma usa il ",l("b",null,"rapporto incrementale"),", in modo da poter essere applicato a funzioni non continue."),l(o.p,null,cl(tl||(tl=pl`\phi (x) = \frac{ 1 }{ \frac{ f(x_{(k)}) - f(x_{(k-1)}) }{ x_{(k)} - x_{(k-1)} } }`))),l(o.p,null,cl(rl||(rl=pl`x_{(k+1)} = x_{(k)} - \frac{ f(x_{(k)}) }{ \frac{ f(x_{(k)}) - f(x_{(k-1)}) }{ x_{(k)} - x_{(k-1)} } }`))),l(a.a,null,"Geometricamente, corrisponde a costruire una retta che attraversa i punti ",l(o.h,null,cl(ul||(ul=pl`(x_{(k)}, f(x_{(k)}))`)))," e ",l(o.h,null,cl(sl||(sl=pl`(x_{(k-1)}, f(x_{(k-1)}))`))),", e prendendo come nuovo punto la sua intersezione con l'asse X e la sua corrispettiva immagine nella funzione."),l("p",null,"Ha costo computazionale di ",l("b",null,"3 valutazioni di funzione"),"."),l("p",null,"Ha ",l("b",null,"convergenza superlineare"),"."))),l(o.r,null,l(o.q,{title:"Approssimare sistemi non-lineari"},l("p",null,"È possibile usare questi metodi per ",l("b",null,"approssimare le soluzioni di sistemi non-lineari"),"."))))}}).call(this,i("hosL").h)},GJGk:function(){},LHkx:function(l,n,i){"use strict";(function(l){i("GJGk");var e=i("hosL"),o=i("mbOI"),a=i("ke5e");let t,r,u,s,p,c,d,m,h,_,f,g,b,z,x,v,q,k,L,A,y,S,w,C,O,I,G,R,M,T,P=l=>l;const F=String.raw;n.a=function(){return l(e.Fragment,null,l(o.r,{title:"Problema: Interpolazione a tratti"},l(o.q,{title:"Come funziona?"},l("p",null,"Invece che costruire una singola funzione che interpola tutti i punti, per ",l("b",null,"ogni intervallo tra due punti")," (",l("i",null,"sottointervallo"),") si costruisce ",l("b",null,"una funzione apposta"),"."))),l(o.r,{title:"Splines"},l(o.q,{title:"Cosa sono?"},l("p",null,"Interpolanti che:"),l("ul",null,l("li",null,"sono ",l("b",null,"polinomiali")," di grado massimo ",l(o.h,null,F(t||(t=P`n`)))),l("li",null,"sono ",l("b",null,"continue")," fino al grado ",l(o.h,null,F(r||(r=P`n - 1`)))),l("li",null,"connettono ",l(o.h,null,F(u||(u=P`m + 2`)))," punti, e hanno ",l(o.h,null,F(s||(s=P`m`)))," sottointervalli"),l("li",null,"hanno funzioni ",l("b",null,"definite appositamente")," per ogni sottointervallo")),l(a.a,null,l("p",null,"Significa che agli estremi dell'intervallo, i valori di tutte le derivate fino al grado ",l(o.h,null,F(p||(p=P`n - 1`)))," devono essere uguali:"),l(o.p,null,F(c||(c=P`\forall \ k \leq n-1, \forall \ i \in \{intervalli\}, \quad s_i^{(k)} (x_{i+1}) = s_i^{(k)} (x_{i+1})`)))),l("p",null,"Hanno ",l(o.h,null,F(d||(d=P`n + m + 1`)))," gradi di libertà."),l(a.a,null,"Esistono infinite spline di grado ",l(o.h,null,F(m||(m=P`n \geq 2`))),"!"))),l(o.r,null,l(o.q,{title:"Spline lineari"},l(a.a,null,"Sono anche dette ",l("b",null,"interpolanti lineari a tratti"),"."),l("p",null,"Per ogni sottointervallo, costruiamo una ",l("b",null,"funzione lineare")," passante per i due estremi:"),l(o.p,null,F(h||(h=P`s_i(x) = y_i + \frac{ y_{i + 1} - y_i }{ x_{i + 1} - x_i } \cdot (x - x_i)`))),l(a.a,null,"È una linea spezzata!"),l("p",null,"Il loro errore è:"),l(o.p,null,F(_||(_=P`\| R \|_\infty = \| f - s \|_\infty \leq \frac{1}{8} \cdot \max_{y \in [a, b]} \left| f''(y) \right| \cdot \left( \max_{i \in \{intervalli\}} (x_{i+1} - x_{i}) \right)^2`))),l("p",null,"Ha come vantaggi complessità computazionale ",l("b",null,"molto più bassa")," e l'",l("b",null,"assenza")," del fenomeno di Runge, ma allo stesso tempo si ",l("b",null,"perde la derivabilità della funzione.")),l("p",null,l("b",null,"Non")," hanno gradi di libertà.")),l(o.q,{title:"Spline cubiche"},l("p",null,"Spline con ",l(o.h,null,F(f||(f=P`n = 3`))),", che soddisfano le seguenti uguaglianze:"),l(o.p,null,F(g||(g=P`
                    \forall \ i \in \{0,\ \dots\ ,\ m - 1\},\ 
                    \begin{cases}
                        s_i (x_{i+1}) = s_{i+1} (x_{i+1})\\\\
                        s'_i (x_{i+1}) = s'_{i+1} (x_{i+1})\\\\
                        s''_i (x_{i+1}) = s''_{i+1} (x_{i+1})
                    \end{cases}                    
                    `))),l(o.p,null,F(b||(b=P`
                    \forall \ i \in \{0,\ \dots\ ,\ m + 1\},\ 
                    \begin{cases}
                        s_i(x_i) = y_i
                    \end{cases}
                    `))),l("p",null,"Esse hanno la seguente equazione:"),l(o.p,null,F(z||(z=P`s_i(x) = \alpha_i + \beta_i \ ( x - x_i ) + \gamma_i \ ( x - x_i )^2 + \delta_i \ ( x - x_i )^3`))),l(a.a,null,"Spesso si indica con ",l(o.h,null,F(x||(x=P`h`)))," la distanza orizzontale tra due punti di un sottointervallo."))),l(o.r,null,l(o.q,{title:"Spline cubica vincolata"},l("p",null,"Classe di spline cubiche in cui:"),l("ul",null,l("li",null,l(o.h,null,F(v||(v=P`\beta_0`)))," e ",l(o.h,null,F(q||(q=P`\beta_{m+1}`)))," sono prefissati")),l("p",null,"È ",l("b",null,"unica"),"."),l("p",null,"Forma il seguente sistema di equazioni:"),l(o.p,null,F(k||(k=P`T z = c`))),l(o.p,null,F(L||(L=P`
                        b_i = h_{i+1} \beta_i + 2 ( h_i + h_{i+1} ) + h_{i} \beta_i+2
                    `))),l(o.p,null,F(A||(A=P`
                        T = 
                        \begin{pmatrix}
                            2 (h_0 + 2 h_1) & h_0 & {\color{Gray} 0} & {\color{Gray} 0} & {\color{Gray} 0} \\\\
                            h_2 & 2 (h_1 + h_2) & h_1 & {\color{Gray} 0} & {\color{Gray} 0} \\\\
                            {\color{Gray} 0} & \ddots & \ddots & \ddots & {\color{Gray} 0} \\\\
                            {\color{Gray} 0} & {\color{Gray} 0} & h_{m-1} & 2 (h_{m-2} + h_{m-1}) & h_{m-2} \\\\
                            {\color{Gray} 0} & {\color{Gray} 0} & {\color{Gray} 0} & h_m & 2 (h_{m-1} + h_m)
                        \end{pmatrix}
                    `))),l(o.p,null,F(y||(y=P`
                        z =
                        \begin{pmatrix}
                            \beta_1\\\\
                            \beta_2\\\\
                            \vdots\\\\
                            \beta_{m-1}\\\\
                            \beta_{m}
                        \end{pmatrix}
                    `))),l(o.p,null,F(S||(S=P`
                        c =
                        \begin{pmatrix}
                            b_0 - h_1 \beta_0\\\\
                            b_1\\\\
                            \vdots\\\\
                            b_{m-2}\\\\
                            b_{m-1} - h_{m-1} \beta_{m+1}
                        \end{pmatrix}
                    `))))),l(o.r,null,l(o.q,{title:"Spline cubica naturale"},l("p",null,"Classe di spline cubiche in cui:"),l("ul",null,l("li",null,l(o.h,null,F(w||(w=P`s''(x_0) = s''(x_{m+1}) = 0`))))),l("p",null,"È ",l("b",null,"unica"),".")),l(o.q,{title:"Spline cubica periodica"},l("p",null,"Classe di spline cubiche in cui:"),l("ul",null,l("li",null,l(o.h,null,F(C||(C=P`s(x) = s(m+1)`)))),l("li",null,l(o.h,null,F(O||(O=P`s'(x) = s'(m+1)`)))),l("li",null,l(o.h,null,F(I||(I=P`s''(x) = s''(m+1)`))))),l("p",null,"È ",l("b",null,"unica"),".")),l(o.q,{title:"Spline cubica not-a-knot"},l("p",null,"Classe di spline cubiche in cui:"),l("ul",null,l("li",null,"Negli intervalli ",l(o.h,null,F(G||(G=P`[x_0, x_2]`)))," e ",l(o.h,null,F(R||(R=P`[x_{m-1}, x_{m+1}]`)))," si presenta ",l("b",null,"obbligatoriamente")," un polinomio di ",l("b",null,"grado 3"),".")),l("p",null,"È ",l("b",null,"unica"),"."))),l(o.r,null,l(o.q,{title:"Proprietà di minima curvatura"},l("p",null,'Tra tutte le funzioni che interpolano dei punti, le tre classi di funzioni sopraelencate sono quelle che interpolano la funzione più "dolcemente".'),l("p",null,"Per loro è valida la seguente proprietà:"),l(o.p,null,F(M||(M=P`\int_a^b ( s''(x) )^2 dx \leq \int_a^b ( f''(x) )^2 dx`)))),l(o.q,{title:"Errore di interpolazione"},l("p",null,"Più diminuisce la lunghezza ",l(o.h,null,F(T||(T=P`h`)))," degli intervalli, più aumenta l'accuratezza."),l("p",null,l("b",null,"Non")," si verifica il fenomeno di Runge."),l("p",null,"Si ha un'interpolazione anche della ",l("b",null,"derivata prima"),"."))))}}).call(this,i("hosL").h)},"T/To":function(){},T2GU:function(l,n,i){"use strict";(function(l){var e=i("5aVd"),o=i.n(e);n.a=function(n){return l("ul",{class:o.a.menulist},n.children)}}).call(this,i("hosL").h)},"h/TB":function(){},ke5e:function(l,n,i){"use strict";(function(l){var e=i("2w3n"),o=i.n(e);n.a=function(n){return l("div",{class:o.a.example},n.children)}}).call(this,i("hosL").h)},lijF:function(l,n,i){"use strict";(function(l){i("zLC0");var e=i("mbOI"),o=i("YNhk"),a=i("ke5e"),t=i("hosL");let r,u,s,p,c,d,m,h,_,f,g,b,z,x,v,q,k,L,A,y,S,w,C,O,I,G,R,M,T,P,F,E,Q,D,N,U,Y,H,j,V,J,X,B,Z,K,W,$,ll,nl,il,el,ol,al,tl,rl,ul,sl,pl,cl,dl,ml,hl,_l,fl,gl,bl=l=>l;const zl=String.raw;n.a=function(){return l(t.Fragment,null,l(e.r,{title:"Problema: Risoluzione di sistemi lineari"},l(e.q,{title:"Descrizione"},l(e.u,null,"TODO")),l(e.q,{title:"Condizionamento"},l("p",null,"Il condizionamento della risoluzione di sistemi lineari è:"),l(e.p,null,zl(r||(r=bl`\frac{{\color{yellow} \|A\| \cdot \|A^{-1}\|} \cdot \| \Delta b \|}{\| b \|}`))),l("p",null,"In particolare, è segnato in giallo nella formula il ",l("b",null,"numero di condizionamento"),":"),l(e.p,null,zl(u||(u=bl`k(A) = \| A \| \cdot \| A^{-1} \|`))))),l(e.r,null,l(e.q,{title:"Metodi diretti"},l("p",null,"Metodi che trovano la soluzione esatta",l("abbr",{title:"Per quanto possibile nell'algebra di macchina."},"*")," di un sistema lineare."),l("p",null,"Tipicamente prevedono la ",l("b",null,"fattorizzazione")," della matrice dei coefficienti in due sottomatrici più facili da risolvere."),l("p",null,"Generalmente hanno una complessità temporale ",l(e.h,null,zl(s||(s=bl`O(n^3)`))),".")),l(e.q,{title:"Metodi iterativi"},l("p",null,"Metodi che trovano una soluzione imperfetta",l("abbr",{title:"Che però può essere la migliore ottenibile, considerando la precisione di macchina."},"*")," di un sistema lineare."),l("p",null,"Tipicamente prevedono l'applicazione ripetuta di un ",l("b",null,"metodo"),", in base al quale cambia la ",l("b",null,"velocità di convergenza")," alla soluzione."),l("p",null,"Generalmente hanno una complessità temporale ",l(e.h,null,zl(p||(p=bl`O(n^2)`))),"."))),l(e.r,{title:"Metodi diretti"},l(e.q,{title:"Divisione"},l("p",null,"Se la matrice dei coefficienti del sistema è ",l("b",null,"diagonale"),", allora è possibile trovare la soluzione ",l("i",null,"dividendo")," ogni termine noto per l'unico coefficiente diverso da zero presente nella sua riga:"),l(e.p,null,zl(c||(c=bl`x_i = \frac{b_i}{A_{ii}}`)))),l(e.q,{title:"Sostituzione"},l("p",null,"Se la matrice dei coefficienti del sistema è ",l("b",null,"triangolare")," inferiore o superiore, allora è possibile trovare la soluzione effettuando una ",l("i",null,"sostituzione")," all'avanti oppure all'indietro:"),l(e.p,null,zl(d||(d=bl`x_i = \frac{b_i - \sum_{k = 1}^{i - 1} (x_k \cdot A_{ik})}{A_{ii}}`))),l(e.p,null,zl(m||(m=bl`x_i = \frac{b_i - \sum_{k = i - 1}^{n} (x_k \cdot A_{ik})}{A_{ii}}`))))),l(e.r,null,l(e.q,{title:l("span",null,"Fattorizzazione ",l(e.h,null,zl(h||(h=bl`LU`))))},l("p",null,"Se la matrice dei coefficienti del sistema ",l("b",null,"non ha ",l(o.a,{href:"https://it.wikipedia.org/wiki/Minore_(algebra_lineare)"},"minori")," uguali a 0 ",l("small",null,"(eccetto l'ultimo)"))," allora è possibile ",l("i",null,"fattorizzarla")," in due matrici: una ",l(e.h,null,zl(_||(_=bl`L`)))," triangolare inferiore, e una ",l(e.h,null,zl(f||(f=bl`U`)))," triangolare superiore."),l(e.p,null,zl(g||(g=bl`A = L \cdot U`))),l(a.a,null,"Abbiamo fatto questo metodo in Algebra Lineare, chiamandolo ",l("b",null,"metodo di Gauss"),"."),l("p",null,"La matrice ",l(e.h,null,zl(b||(b=bl`L`)))," è così composta:"),l(e.p,null,zl(z||(z=bl`
                        \begin{cases}
                            L_{ii} = 1 \qquad \qquad (diagonale)\\
                            L_{ik} = -\frac{A_{ik}}{A_{kk}} \qquad (tri.\ infer.)
                        \end{cases}
                    `))),l(a.a,null,"Sono i moltiplicatori usati per rendere annullare il triangolo inferiore!"),l("p",null,"La matrice ",l(e.h,null,zl(x||(x=bl`U`)))," è così composta:"),l(e.p,null,zl(v||(v=bl`
                        \begin{cases}
                            U_{ik} = A_{ik} \quad se\ i \leq k \quad (tri.\ super.)\\
                            U_{ik} = 0 \qquad se\ i > k \quad (tri.\ infer.)
                        \end{cases}
                    `))),l("p",null,"Il sistema può essere poi risolto applicando due volte il metodo di sostituzione:"),l(e.p,null,zl(q||(q=bl`
                        \begin{cases}
                            L \cdot y = b\\
                            U \cdot x = y
                        \end{cases}
                    `))),l("p",null,"Questo metodo ha costo computazionale:"),l(e.p,null,zl(k||(k=bl`{\color{Yellow} O\left(\frac{n^3}{3}\right)} + 2 \cdot O\left(\frac{n^2}{2}\right)`)))),l(e.q,{title:l("span",null,"Fattorizzazione ",l(e.h,null,zl(L||(L=bl`LU`)))," con pivoting parziale")},l("p",null,"È possibile applicare la fattorizzazione ",l(e.h,null,zl(A||(A=bl`LU`)))," a ",l("b",null,"qualsiasi matrice non-singolare")," permettendo lo scambio (",l("i",null,"pivoting"),") delle righe, potenzialmente ",l("b",null,"aumentando la stabilità")," dell'algoritmo."),l(a.a,null,"Abbiamo fatto questo metodo in Algebra Lineare, chiamandolo ",l("b",null,"metodo di Gauss-Jordan"),"!"),l("p",null,"Alla formula precedente si aggiunge una ",l(o.a,{href:"https://it.wikipedia.org/wiki/Matrice_di_permutazione"},"matrice di permutazione")," che indica quali righe sono state scambiate:"),l(e.p,null,zl(y||(y=bl`P \cdot A = L \cdot U`))),l("p",null,"Questo metodo ha costo computazionale:"),l(e.p,null,zl(S||(S=bl`{\color{Yellow} O\left(\frac{n^2}{2}\right)} + O\left(\frac{n^3}{3}\right) + 2 \cdot O\left(\frac{n^2}{2}\right)`)))),l(e.q,{title:l("span",null,"Fattorizzazione ",l(e.h,null,zl(w||(w=bl`LU`)))," con pivoting totale")},l("p",null,"È possibile anche permettere il ",l("i",null,"pivoting")," ",l("b",null,"sulle colonne")," per ",l("b",null,"aumentare ulteriormente la stabilità")," dell'algoritmo, a costo di maggiore costo computazionale:"),l(e.p,null,zl(C||(C=bl`P \cdot A \cdot Q = L \cdot U`))),l("p",null,"Questo metodo ha costo computazionale:"),l(e.p,null,zl(O||(O=bl`{\color{Yellow} O\left(\frac{n^3}{3}\right)} + O\left(\frac{n^3}{3}\right) + 2 \cdot O\left(\frac{n^2}{2}\right)`))))),l(e.r,null,l(e.q,{title:l("span",null,"Fattorizzazione ",l(e.h,null,zl(I||(I=bl`LDL^{-1}`))))},l("p",null,"È possibile ",l("b",null,"ridurre la complessità computazionale")," della fattorizzazione ",l(e.h,null,zl(G||(G=bl`LU`)))," se la matrice dei coefficienti è ",l("b",null,"simmetrica"),":"),l(e.p,null,zl(R||(R=bl`A = L \cdot D \cdot L^{-1}`))),l("p",null,"In questo caso, si calcola solo la matrice L, utilizzando il ",l("b",null,"metodo di pavimentazione"),"."),l(e.p,null,zl(M||(M=bl`
                        \begin{cases}
                            d_{ii} = A_{ii} - \sum_{k=1}^{i-1} ( d_{kk} \cdot (l_{jk})^2 )\\
                            \\
                            l_{ij} = \frac{A_{ij} - \sum_{k=1}^{j-1} l_{ik} \cdot d_{kk} \cdot l_{jk}}{d_{ii}}
                        \end{cases}
                    `))),l(a.a,null,l("p",null,"La prima colonna della matrice sarà:"),l(e.p,null,zl(T||(T=bl`
                            \begin{cases}
                                d_{11} = A_{11}\\
                                \\
                                l_{i1} = \frac{A_{i1}}{d_{11}}
                            \end{cases}
                        `))),l("p",null,"La seconda colonna della matrice sarà:"),l(e.p,null,zl(P||(P=bl`
                            \begin{cases}
                                d_{22} = A_{22} - d_{11} \cdot (l_{21})^2\\
                                \\
                                l_{i2} = \frac{A_{i2} - l_{i1} \cdot d_{11} \cdot l_{21}}{d_{ii}}
                            \end{cases}
                        `)))),l("p",null,"Questo metodo ha costo computazionale:"),l(e.p,null,zl(F||(F=bl`{\color{Yellow} O\left(\frac{n^3}{6}\right)} + O\left(\frac{n^3}{3}\right) + 2 \cdot O\left(\frac{n^2}{2}\right)`)))),l(e.q,{title:l("span",null,"Fattorizzazione ",l(e.h,null,zl(E||(E=bl`\mathcal{L} \mathcal{L}^{-1}`))))},l("p",null,"È possibile dare ",l("b",null,"stabilità forte")," alla fattorizzazione ",l(e.h,null,zl(Q||(Q=bl`LDL^{-1}`)))," se la matrice dei coefficienti è ",l("b",null,"simmetrica definita positiva"),":"),l(e.p,null,zl(D||(D=bl`A = \mathcal{L} \cdot \mathcal{L}^{-1}`))),l("p",null,"Il ",l("b",null,"metodo di pavimentazione")," diventa:"),l(e.p,null,zl(N||(N=bl`
                        \begin{cases}
                            l_{ii} = \sqrt{A_{ii} - \sum_{k=1}^{i-1}  (l_{ik})^2 }\\
                            \\
                            l_{ij} = \frac{A_{ij} - \sum_{k=1}^{j-1} l_{ik} \cdot l_{jk}}{l_{ii}}
                        \end{cases}
                    `))),l("p",null,"Questo metodo ha costo computazionale:"),l(e.p,null,zl(U||(U=bl`O\left(\frac{n^3}{3}\right) + O\left(\frac{n^3}{3}\right) + 2 \cdot O\left(\frac{n^2}{2}\right)`))))),l(e.r,null,l(e.q,{title:"Trasformazione di Householder"},l("p",null,"Matrice ricavata dalla seguente formula:"),l(e.p,null,zl(Y||(Y=bl`U(v) = I - \frac{1}{\alpha} \cdot v \cdot v^T`))),l(e.p,null,zl(H||(H=bl`\alpha = \frac{1}{2} \| v \|_{(2)}^2`)))),l(e.q,{title:l("span",null,"Fattorizzazione ",l(e.h,null,zl(j||(j=bl`QR`))))},l("p",null,"Metodo che fornisce una ",l("b",null,"maggiore stabilità")," a costo di una ",l("b",null,"maggiore complessità computazionale"),"."),l("p",null,"La matrice ",l(e.h,null,zl(V||(V=bl`A`)))," viene ",l("i",null,"fattorizzata")," in due matrici, una ",l("b",null,"ortogonale")," ",l(e.h,null,zl(J||(J=bl`Q`)))," e una ",l("b",null,"triangolare superiore")," ",l(e.h,null,zl(X||(X=bl`R`))),":"),l(e.p,null,zl(B||(B=bl`A = Q \cdot R`))),l("p",null,"Le matrici si ottengono dal prodotto delle trasformazioni di Householder (",l(e.h,null,zl(Z||(Z=bl`Q`)))," sulle colonne della matrice ",l(e.h,null,zl(K||(K=bl`A`))),", trasformandola in una matrice triangolare superiore (",l(e.h,null,zl(W||(W=bl`R`))),")."),l("p",null,"Una volta fattorizzata, il sistema si può risolvere con:"),l(e.p,null,zl($||($=bl`
                        \begin{cases}
                            y = Q^T \cdot b\\
                            R \cdot x = y
                        \end{cases}
                    `))),l("p",null,"Questo metodo ha costo computazionale:"),l(e.p,null,zl(ll||(ll=bl`{\color{Yellow} O\left(\frac{2 \cdot n^3}{3}\right)} + 2 \cdot O\left(\frac{n^2}{2}\right)`))),l("p",null,l(e.u,null,"TODO: l'algoritmo con tau per ricavare la q se non è in memoria")))),l(e.r,{title:"Metodi iterativi"},l(e.q,{title:"Forma generale"},l("p",null,"Se si pone che:"),l(e.p,null,zl(nl||(nl=bl`
                        \begin{cases}
                            G = I - M^{-1} \cdot A\\
                            c = M^{-1} \cdot b
                        \end{cases}
                    `))),l("p",null,"Allora la formula generale di un sistema lineare può anche essere scritta in questo modo:"),l(e.p,null,zl(il||(il=bl`x = G \cdot x + c`))),l("p",null,"È particolarmente utile perchè ci permette di definire un ",l("b",null,"algoritmo ricorsivo")," che trovi ",l(e.h,null,zl(el||(el=bl`x`))),":"),l(e.p,null,zl(ol||(ol=bl`x_{(i+1)} = G \cdot x_{(i)} + c`))),l("p",null,l(e.h,null,zl(al||(al=bl`G`)))," è il ",l("b",null,"metodo"),", e in base ad esso cambiano stabilità e velocità di convergenza."),l("p",null,"Ponendo ",l(e.h,null,zl(tl||(tl=bl`A = M - N`))),", la formula può essere scritta anche in questo modo:"),l(e.p,null,zl(rl||(rl=bl`M \cdot x_{(i+1)} = N \cdot x_{(i)} + b`))),l("p",null,"Possiamo ottenere alcuni metodi separando ",l(e.h,null,"A")," in tre matrici:"),l("ul",null,l("li",null,"La parte diagonale ",l(e.h,null,zl(ul||(ul=bl`D`)))),l("li",null,"L'opposto del triangolo inferiore ",l(e.h,null,zl(sl||(sl=bl`E`)))),l("li",null,"L'opposto del triangolo superiore ",l(e.h,null,zl(pl||(pl=bl`F`))))),l(e.p,null,zl(cl||(cl=bl`A = D - E - F`)))),l(e.q,{title:"Convergenza di un metodo"},l("p",null,"Un metodo è convergente se e solo se:"),l(e.p,null,zl(dl||(dl=bl`\rho (M) < 1`))),l("p",null,"(dove ",l(e.h,null,zl(ml||(ml=bl`\rho`)))," è il ",l("b",null,"raggio spettrale"),", il massimo autovalore della matrice)"),l("p",null,"Perchè un metodo sia convergente, è sufficiente che:"),l(e.p,null,zl(hl||(hl=bl`\| M \| < 1`))),l("p",null,l(e.u,null,"TODO: l'algoritmo con tau per le condizioni di arresto")))),l(e.r,null,l(e.q,{title:"Metodo di Jacobi"},l("p",null,"Il metodo di Jacobi si ottiene ponendo:"),l(e.p,null,zl(_l||(_l=bl`
                        \begin{cases}
                            M = D\\
                            N = E + F
                        \end{cases}
                    `))),l("p",null,l("u",null,"Spostamenti simultanei"),": Permette di ottenere ogni componente di ",l(e.h,null,zl(fl||(fl=bl`x`)))," indipendentemente dagli altri: è ",l("b",null,"parallelizzabile"),"."),l("p",null,"Se la matrice è ",l("b",null,"diagonale dominante"),", allora il metodo di Jacobi ",l("b",null,"converge")," sicuramente.")),l(e.q,{title:"Metodo di Gauss-Seidel"},l("p",null,"Il metodo di Gauss-Seidel si ottiene ponendo:"),l(e.p,null,zl(gl||(gl=bl`
                        \begin{cases}
                            M = D - E\\
                            N = F
                        \end{cases}
                    `))),l("p",null,"Ha una velocità di convergenza ",l("b",null,"maggiore o uguale")," rispetto al metodo di Jacobi."),l("p",null,l("u",null,"Spostamenti successivi"),": Non è parallelizzabile, perchè ogni componente ",l("b",null,"dipende da quelle calcolate in precedenza"),"."),l("p",null,"Se la matrice è ",l("b",null,"diagonale dominante"),", allora il metodo di Gauss-Seidel ",l("b",null,"converge")," sicuramente."))))}}).call(this,i("hosL").h)},qXt2:function(l,n,i){"use strict";i.r(n),function(l){var e=i("sl5E"),o=i("lijF"),a=i("FEtp"),t=i("31Ft"),r=i("LHkx"),u=i("uqDQ");n.default=function(){return l("div",null,l("h1",null,"Calcolo Numerico"),l(e.a,null),l(o.a,null),l(a.a,null),l(t.a,null),l(r.a,null),l(u.a,null))}}.call(this,i("hosL").h)},sl5E:function(l,n,i){"use strict";(function(l){i("T/To");var e=i("mbOI"),o=i("YNhk"),a=i("T2GU"),t=i("ke5e"),r=i("hosL");let u,s,p,c,d,m,h,_,f,g,b,z,x,v,q,k,L,A,y,S,w,C=l=>l;const O=String.raw;n.a=function(){return l(r.Fragment,null,l(e.r,{title:"Esame"},l(e.q,{title:"Contatti"},l("ul",null,l("li",null,l(o.a,{href:"mailto:silvia.bonettini@unimore.it"},"Prof.ssa Silvia Bonettini")))),l(e.q,{title:"Orale"},l("p",null,"E' composto da:"),l("ul",null,l("li",null,"2 domande sugli argomenti teorici"),l("li",null,"1 domanda di implementazione algoritmo in MATLAB"))),l(e.q,{title:"Sessione autunnale"},l("ol",null,l("li",null,l(e.t,{to:"2020-08-31 09:00"})),l("li",null,l(e.t,{to:"2020-09-14 09:00"}))))),l(e.r,{title:"Informazioni"},l(e.q,{title:"Ripasso di Algebra Lineare"},l("p",null,"Prima di iniziare a studiare Calcolo Numerico, potrebbe essere una buona idea ripassare un pochino Algebra Lineare:"),l(a.a,null,l("li",null,l("a",{href:"/calcolonumerico/ripassodialgebralineare"},"Ripasso di Algebra Lineare")," ",l("small",null,"(per studenti sperduti di Calcolo Numerico)"))))),l(e.r,{title:"Algoritmi"},l(e.q,{title:"Algoritmi numerici"},l("p",null,"Particolari algoritmi che hanno:"),l("ul",null,l("li",null,"numeri reali in input e output"),l("li",null,"successioni delle quattro operazioni aritmetiche fondamentali come passi")))),l(e.r,{title:"Errore di rappresentazione"},l(e.q,{title:"Cos'è?"},l("p",null,"Con i numeri floating point può capitare che un certo numero ",l(e.h,null,O(u||(u=C`\alpha`)))," non sia rappresentato correttamente."),l("p",null,"In tal caso, il numero si indica con ",l(e.h,null,O(s||(s=C`\alpha^*`))),"."))),l(e.r,null,l(e.q,{title:"Errore assoluto"},l("p",null,"È la differenza tra il numero desiderato e il numero rappresentato:"),l(e.p,null,O(p||(p=C`E_a = \left | \alpha - \alpha^* \right |`)))),l(e.q,{title:"Errore relativo"},l("p",null,"Indica quanto il numero rappresentato differisce dal numero desiderato:"),l(e.p,null,O(c||(c=C`\forall \alpha \neq 0, E_r = \frac{E_a}{\left | \alpha \right |}`))))),l(e.r,null,l(e.q,{title:"Troncamento"},l("p",null,"Metodo con cui gestire gli ",l("b",null,"underflow floating point"),": le cifre meno significative vengono ",l("b",null,"rimosse"),"."),l(t.a,null,l("pre",null,"1.00  →  1.0",l("br",null),"1.01  →  1.0",l("br",null),"1.10  →  1.1",l("br",null),"1.11  →  1.1"))),l(e.q,{title:"Arrotondamento"},l("p",null,"Metodo con cui gestire gli ",l("b",null,"underflow floating point"),": se la cifra più significativa di quelle che devono essere rimosse è 1, allora ",l("b",null,"aumenta di 1")," anche quella meno signficativa che viene tenuta."),l(t.a,null,l("pre",null,"1.00  →  1.0",l("br",null),"1.01  →  1.0",l("br",null),"1.10  →  1.1",l("br",null),"1.11  → 10.")))),l(e.r,null,l(e.q,{title:"Precisione di macchina"},l("p",null,"Un numero reale rappresentato in ",l("b",null,"virgola mobile")," ha un ",l("b",null,"errore relativo")," minore o uguale alla ",l("i",null,"precisione di macchina"),":"),l("p",null,l(e.h,null,O(d||(d=C`E_r \leq k \cdot \beta^{1-t}`)))),l("ul",null,l("li",null,l(e.h,null,"\\beta")," è uguale alla base utilizzata (solitamente 2)."),l("li",null,l(e.h,null,"t")," è uguale al numero di cifre della mantissa."),l("li",null,l(e.h,null,"k")," è uguale a ",l(e.h,null,"1")," se il numero viene rappresentato per troncamento oppure a ",l(e.h,null,O(m||(m=C`\frac{1}{2}`)))," se viene rappresentato per arrotondamento."))),l(e.q,{title:"La funzione fl"},l("p",null,"Associa un valore reale al suo ",l("b",null,"corrispondente valore floating point"),", utilizzando uno dei due metodi di gestione dell'undeflow."),l(e.p,null,O(h||(h=C`fl(x) = (x)(1 + \epsilon_x)`))),l(t.a,null,"Indica che un valore è soggetto alla precisione di macchina.",l(e.p,null,O(_||(_=C`fl(1.11) = 1.1`)))))),l(e.r,null,l(e.q,{title:"Un nuovo insieme"},l("p",null,"L'insieme ",l(e.h,null,O(f||(f=C`\mathbb{F}`)))," è il sottoinsieme dei numeri reali rappresentabili in floating point dalla macchina che stiamo usando."),l("p",null,"Operazioni tra elementi di ",l(e.h,null,O(g||(g=C`\mathbb{F}`)))," producono risultati in ",l(e.h,null,O(b||(b=C`\mathbb{R}`))),", che però decaderanno nuovamente a elementi di ",l(e.h,null,O(z||(z=C`\mathbb{F}`))),", perdendo informazioni."),l("p",null,"Il teorema della precisione di macchina si applica quindi anche ai risultati delle operazioni.")),l(e.q,{title:"Caratteristiche delle operazioni di macchina"},l("ul",null,l("li",null,"Hanno ",l("b",null,"più elementi neutri"),"."),l("li",null,"Un numero ha ",l("b",null,"più opposti"),"."),l("li",null,l("b",null,"Non")," sono associative."),l("li",null,l("b",null,"Non")," sono distributive."),l("li",null,l("b",null,"Non")," vale la legge di annullamento del prodotto.")))),l(e.r,{title:"Errori nelle operazioni di macchina"},l(e.q,{title:"Errore inerente"},l("p",null,"Errore derivato da underflow sui ",l("b",null,"dati"),"."),l("p",null,"Si indica con ",l(e.h,null,O(x||(x=C`\epsilon_{nome\_var}`))),"."),l(t.a,null,"L'errore sulla variabile ",l(e.h,null,"x")," si indica con ",l(e.h,null,O(v||(v=C`\epsilon_{x}`))),".")),l(e.q,{title:"Errore algoritmico"},l("p",null,"Errore derivato da underflow durante l'",l("b",null,"esecuzione dell'algoritmo"),"."),l("p",null,"Si indica con ",l(e.h,null,O(q||(q=C`\epsilon_{num\_passo}`))),"."),l(t.a,null,"L'errore al primo passo dell'algoritmo si indica con ",l(e.h,null,O(k||(k=C`\epsilon_{1}`))),"."))),l(e.r,null,l(e.q,{title:"Condizionamento"},l("p",null,"Sensibilità di un problema all'",l("b",null,"errore inerente"),"."),l(t.a,null,l(e.h,null,O(L||(L=C`y = \frac{1}{x}`)))," è mal condizionato intorno allo 0 e ben condizionato lontano dallo 0.")),l(e.q,{title:"Stabilità"},l("p",null,"Sensibilità di un problema all'",l("b",null,"errore algoritmico"),"."),l(t.a,null,l("p",null,"Cerchiamo un algoritmo che risolva ",l(e.h,null,O(A||(A=C`2x^* = 4`))),"."),l("p",null,"Calcolare prima ",l(e.h,null,O(y||(y=C`t = fl \left( \frac{1}{4} \right)`)))," e poi ",l(e.h,null,O(S||(S=C`x = fl ( 2 \cdot t )`)))," porta a una perdita di precisione."),l("p",null,"Calcolare direttamente ",l(e.h,null,O(w||(w=C`x = fl \left( \frac{2}{4} \right)`)))," non ha alcuna perdita di precisione e rende l'algoritmo ",l("b",null,"più stabile")," del precedente.")))),l(e.r,null,l(e.q,{title:"Indice di condizionamento"},l("p",null,"È il coefficiente di proporzionalità tra i dati e l'",l("b",null,"errore inerente"),"."),l("p",null,"Essendo sempre maggiore di uno, si può dire che sia un coefficiente di amplificazione."),l("p",null,"Minore è l'indice di condizionamento, meglio condizionato è un problema.")),l(e.q,{title:"Indice algoritmico"},l("p",null,"È il coefficiente di proporzionalità tra i dati e l'",l("b",null,"errore algoritmico"),"."),l("p",null,"Essendo sempre maggiore di uno, si può dire che sia un coefficiente di amplificazione."))))}}).call(this,i("hosL").h)},uV4c:function(){},uqDQ:function(l,n,i){"use strict";(function(l){i("uV4c");var e=i("hosL"),o=i("mbOI"),a=i("ke5e");let t,r,u,s,p,c,d,m,h,_,f,g,b,z,x,v,q,k,L,A,y,S,w,C,O,I,G,R,M,T,P,F,E,Q,D,N,U,Y,H,j,V,J,X,B,Z,K,W,$,ll,nl,il=l=>l;const el=String.raw;n.a=function(){return l(e.Fragment,null,l(o.r,{title:"Problema: Approssimazione di dati sperimentali"},l(o.q,{title:"Perchè?"},l("p",null,"Interpolare dati sperimentali non fornisce quasi mai un modello del fenomeno."),l("p",null,"Vogliamo costruire una ",l("b",null,"funzione di regressione")," che, dati molti più dati del grado della funzione, minimizzi il quadrato della distanza tra i punti sperimentali e i punti della funzione di regressione."),l("p",null,"Denominiamo:"),l("ul",null,l("li",null,l(o.h,null,el(t||(t=il`{\color{Orange} f}`))),": la ",l("b",null,'funzione "effettiva"')," del fenomeno"),l("li",null,l(o.h,null,el(r||(r=il`{\color{Yellow} q}`))),": la ",l("b",null,"funzione di regressione")," che costruiamo per approssimarlo"),l("li",null,l(o.h,null,el(u||(u=il`{\color{Red} Q }`))),": la ",l("b",null,'funzione "errore di regressione"')," da minimizzare"),l("li",null,l(o.h,null,el(s||(s=il`(\ x_i, f(x_i)\ )`))),": i ",l("b",null,"punti sperimentali"))),l("p",null,"L'obiettivo è minimizzare l'",l("b",null,"errore di approssimazione")," ",l(o.h,null,el(p||(p=il`Q`))),", ovvero:"),l(o.p,null,el(c||(c=il`\min {\color{Red} Q } = \sum_{i = 1}^m (\ {\color{Yellow} q(x_i)} - {\color{Orange} f(x_i)}\ )^2 `))))),l(o.r,null,l(o.q,{title:"Regressione lineare"},l("p",null,"Trova la ",l("b",null,"retta")," ",l(o.h,null,el(d||(d=il`{\color{Yellow} q}`)))," che meglio approssima tutti gli ",l(o.h,null,el(m||(m=il`m`)))," dati sperimentali."),l("p",null,"Essendo una retta, avrà ",l("b",null,"due parametri"),": il termine noto ",l(o.h,null,el(h||(h=il`a_0`))),", e la pendenza ",l(o.h,null,"a_1"),"."),l(o.p,null,el(_||(_=il`{\color{Yellow} q(x) } = a_0 + a_1 \cdot {\color{Green} x}`))),l("p",null,"L'errore da minimizzare per ricavare i parametri sarà:"),l(o.p,null,el(f||(f=il`
                        \min {\color{Red} Q } = \sum_{i = 1}^m ( {\color{Yellow} a_0 + a_1 \cdot x_i} - {\color{Orange} f(x_i)} )^2
                    `)))),l(o.q,{title:"Regressione lineare matriciale"},l("p",null,"Possiamo costruire una ",l("b",null,"matrice di regressione")," ",l(o.h,null,el(g||(g=il`A`)))," contenente tutti i ",l("b",null,"punti sperimentali"),":"),l(o.p,null,el(b||(b=il`
                        A =
                        \begin{pmatrix}
                            1 & x_1\\\\
                            1 & x_2\\\\
                            \vdots & \vdots\\\\
                            1 & x_m
                        \end{pmatrix}
                    `))),l("p",null,"Inoltre, se costruiamo il ",l("b",null,"vettore dei parametri")," ",l(o.h,null,el(z||(z=il`\alpha`))),":"),l(o.p,null,el(x||(x=il`
                        \alpha =
                        \begin{pmatrix}
                            a_0\\\\
                            a_1
                        \end{pmatrix}
                    `))),l("p",null,"Avremo che:"),l(o.p,null,el(v||(v=il`{\color{Yellow} q(x) } = A \cdot \alpha`))),l("p",null,"Inoltre, potremo calcolare l'errore attraverso la norma:"),l(o.p,null,el(q||(q=il`{\color{Red} Q } = \| A \cdot \alpha - y \|^2`))))),l(o.r,null,l(o.q,{title:"Regressione polinomiale"},l("p",null,"Trova il ",l("b",null,"polinomio")," ",l(o.h,null,el(k||(k=il`{\color{Yellow} q}`)))," di grado ",l(o.h,null,el(L||(L=il`n-1`)))," che meglio approssima tutti gli ",l(o.h,null,el(A||(A=il`m`)))," dati sperimentali."),l("p",null,"Essendo un polinomio di grado ",l(o.h,null,el(y||(y=il`n-1`))),", avrà ",l(o.h,null,el(S||(S=il`n`)))," parametri."),l(o.p,null,el(w||(w=il`{\color{Yellow} q(x) } = a_0 + a_1 \cdot {\color{Green} x} + a_2 \cdot {\color{Green} x^2} +\ \dots \ + a_{n-1} \cdot {\color{Green} x^{n-1}`))),l(a.a,null,l("p",null,"La regressione lineare è un caso particolare di regressione generale in cui i parametri sono 2!")),l("p",null,"L'errore da minimizzare per ricavare i parametri sarà:"),l(o.p,null,el(C||(C=il`
                        \min {\color{Red} Q} = \sum_{i = 1}^m ( {\color{Yellow} a_0 + a_1 \cdot x_i + a_2 \cdot x_i^2 +\ \dots \ + a_{n-1} \cdot x_i^{n-1}} - {\color{Orange} y_i} )^2
                    `)))),l(o.q,{title:"Regressione polinomiale matriciale"},l("p",null,"Possiamo costruire una ",l("b",null,"matrice di regressione")," ",l(o.h,null,el(O||(O=il`A`)))," contenente tutti i ",l("b",null,"punti sperimentali")," a tutti i gradi del polinomio:"),l(o.p,null,el(I||(I=il`
                        A =
                        \begin{pmatrix}
                            1 & x_1 & x_1^2 & \dots & x_1^{n-1} \\\\
                            1 & x_2 & x_2^2 & \dots & x_2^{n-1} \\\\
                            \vdots & \vdots & \vdots & \ddots & \vdots \\\\
                            1 & x_m & x_m^2 & \dots & x_m^{n-1}
                        \end{pmatrix}
                    `))),l("p",null,"Inoltre, se costruiamo il ",l("b",null,"vettore dei parametri")," ",l(o.h,null,el(G||(G=il`\alpha`))),":"),l(o.p,null,el(R||(R=il`
                        \alpha =
                        \begin{pmatrix}
                            a_0\\\\
                            a_1\\\\
                            \vdots\\\\
                            a_{n-1}
                        \end{pmatrix}
                    `))),l("p",null,"Avremo che:"),l(o.p,null,el(M||(M=il`{\color{Yellow} q(x) } = A \cdot \alpha`))),l("p",null,"Inoltre, potremo calcolare l'errore attraverso la norma:"),l(o.p,null,el(T||(T=il`{\color{Red} Q } = \| A \cdot \alpha - y \|^2`))),l(a.a,null,"Normalmente, i dati sono molti di più, ma se il numero di parametri ",l(o.h,null,el(P||(P=il`n`)))," fosse uguale al numero di dati ",l(o.h,null,el(F||(F=il`m`))),", allora si otterrebbe il ",l("b",null,"polinomio di interpolazione"),"!"))),l(o.r,null,l(o.q,{title:"Regressione generale"},l("p",null,"Trova i ",l("b",null,"coefficienti della combinazione lineare")," ",l(o.h,null,el(E||(E=il`{\color{Yellow} q}`)))," che meglio approssima tutti gli ",l(o.h,null,el(Q||(Q=il`m`)))," dati sperimentali."),l(o.p,null,el(D||(D=il`{\color{Yellow} q(x) } = a_0 \cdot {\color{Green} \phi_0 (x)} + a_1 \cdot {\color{Green} \phi_1 (x)} + \dots + a_2 \cdot {\color{Green} \phi_2 (x)} +\ \dots\ + a_{n-1} \cdot {\color{Green} \phi_{n-1} (x)}`))),l(a.a,null,l("p",null,"La regressione polinomiale è un caso particolare di regressione generale in cui:"),l(o.p,null,el(N||(N=il`{\color{Green} \phi_{n} (x)} = x^n`)))),l("p",null,"L'errore da minimizzare per ricavare i parametri sarà:"),l(o.p,null,el(U||(U=il`
                        \min {\color{Red} Q } = \sum_{i = 1}^m ( {\color{Yellow} a_0 \cdot \phi_0 (x) + a_1 \cdot \phi_1 (x) + \dots + a_2 \cdot \phi_2 (x) +\ \dots\ + a_{n-1} \cdot \phi_{n-1} (x)} - {\color{Orange} f(x_i)} )^2
                    `)))),l(o.q,{title:"Regressione polinomiale generale"},l("p",null,"Possiamo costruire una ",l("b",null,"matrice di regressione")," ",l(o.h,null,el(Y||(Y=il`A`)))," contenente tutti i ",l("b",null,"punti sperimentali")," a tutti i gradi del polinomio:"),l(o.p,null,el(H||(H=il`
                        A =
                        \begin{pmatrix}
                            \phi_0(x_1) & \phi_1(x_1) & \phi_2(x_1) & \dots & \phi_{n_1}(x_1) \\\\
                            \phi_0(x_2) & \phi_1(x_2) & \phi_2(x_2) & \dots & \phi_{n-1}(x_2) \\\\
                            \vdots & \vdots & \vdots & \ddots & \vdots \\\\
                            \phi_0(x_m) & \phi_1(x_m) & \phi_2(x_m) & \dots & \phi_{n-1}(x_m)
                        \end{pmatrix}
                    `))),l("p",null,"Inoltre, se costruiamo il ",l("b",null,"vettore dei parametri")," ",l(o.h,null,el(j||(j=il`\alpha`))),":"),l(o.p,null,el(V||(V=il`
                        \alpha =
                        \begin{pmatrix}
                            a_0\\\\
                            a_1\\\\
                            \vdots\\\\
                            a_{n-1}
                        \end{pmatrix}
                    `))),l("p",null,"Avremo che:"),l(o.p,null,el(J||(J=il`{\color{Yellow} q(x) } = A \cdot \alpha`))),l("p",null,"Inoltre, potremo calcolare l'errore attraverso la norma:"),l(o.p,null,el(X||(X=il`{\color{Red} Q } = \| A \cdot \alpha - y \|^2`))))),l(o.r,{title:"Trovare i parametri"},l(o.q,{title:"Caso non degenere"},l("p",null,"Caso che prevede che le colonne di ",l(o.h,null,el(B||(B=il`A`)))," siano ",l("b",null,"linearmente indipendenti"),"."),l("p",null,"La soluzione ",l("b",null,"esiste")," sempre, ed è ",l("b",null,"unica"),"."),l("p",null,"Per trovarla:"),l("ul",null,l("li",null,"Fattorizziamo ",l(o.h,null,el(Z||(Z=il`A = Q \cdot \begin{pmatrix} R\\ 0 \end{pmatrix}`))),"."),l("li",null,"Calcoliamo ",l(o.h,null,el(K||(K=il`w = Q^T \cdot y`))),"."),l("li",null,"Teniamo solo i primi ",l(o.h,null,"n")," valori di ",l(o.h,null,el(W||(W=il`w`)))," e mettiamoli in ",l(o.h,null,el($||($=il`w_1`))),"."),l("li",null,"Calcoliamo ",l(o.h,null,el(ll||(ll=il`R \cdot \alpha = w_1`))),"."))),l(o.q,{title:"Caso generale"},l("p",null,"Caso che non preclude alcuna composizione di ",l(o.h,null,el(nl||(nl=il`A`))),"."))))}}).call(this,i("hosL").h)},zLC0:function(){}}]);
//# sourceMappingURL=route-CalcoloNumerico.chunk.09ebc.esm.js.map