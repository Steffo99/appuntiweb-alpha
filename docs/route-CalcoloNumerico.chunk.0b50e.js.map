{"version":3,"sources":["webpack:///./components/Example.less","webpack:///./routes/CalcoloNumerico/03_Interpolazione.js","webpack:///./components/MenuList.less","webpack:///./routes/CalcoloNumerico/02_ZeriDiFunzione.js","webpack:///../src/components/Panels/Box.js","webpack:///../src/contexts/CurrentPage.js","webpack:///../src/contexts/LatexRenderColor.js","webpack:///../src/contexts/LatexDefaultInline.js","webpack:///../src/contexts/LatexDefaultDisplay.js","webpack:///../src/contexts/RoyalnetInstanceUrl.js","webpack:///../src/contexts/RoyalnetLoginStatus.js","webpack:///../src/utils/royalnetApiRequest.js","webpack:///./routes/CalcoloNumerico/04_InterpolazioneATratti.js","webpack:///./components/MenuList.js","webpack:///./components/Example.js","webpack:///./routes/CalcoloNumerico/01_SistemiLineari.js","webpack:///./routes/CalcoloNumerico/index.js","webpack:///./routes/CalcoloNumerico/00_Intro.js","webpack:///./routes/CalcoloNumerico/05_ApprossimazioneDatiSperimentali.js"],"names":["module","exports","r","String","raw","title","BoxColors","createContext","Object","freeze","RED","ORANGE","YELLOW","LIME","CYAN","BLUE","MAGENTA","DEFAULT","Error","props","class","style","menulist","children","example","href","to","color"],"mappings":"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","file":"route-CalcoloNumerico.chunk.0b50e.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"red\":\"red__2y1B_\",\"orange\":\"orange__dD2kx\",\"yellow\":\"yellow__OEpwl\",\"lime\":\"lime__CVe41\",\"cyan\":\"cyan__26ZAg\",\"blue\":\"blue__LO7Xm\",\"magenta\":\"magenta__1Akee\",\"example\":\"example__2PzAa\"};","import style from \"./03_Interpolazione.less\";\nimport {Fragment} from \"preact\";\nimport {Section, Panel, ILatex, BLatex, PLatex, Todo} from \"bluelib\";\nimport Example from \"../../components/Example\";\n\nconst r = String.raw;\n\n\nexport default function (props) {\n    return (\n        <Fragment>\n            <Section title={\"Problema: Interpolazione\"}>\n                <Panel title={\"Descrizione\"}>\n                    <p>\n                        Si vuole trovare una funzione in grado di <b>approssimarne</b> un'altra, di cui si conoscono però solo alcuni punti.\n                    </p>\n                    <Example>\n                        È utile in un sacco di casi! Ad esempio, quando si vuole scalare un'immagine.\n                    </Example>\n                    <p>\n                        I punti sono detti <b>nodi</b> <ILatex>{r`(x_i, y_i)`}</ILatex>, mentre la funzione costruita su di essi è detta <b>interpolante</b> <ILatex>{r`g`}</ILatex>:\n                    </p>\n                    <PLatex>{r`g(x_i) = y_i`}</PLatex>\n                    <p>\n                        Dato un insieme di punti, esistono <b>infinite</b> funzioni interpolanti.\n                    </p>\n                </Panel>\n                <Panel title={\"Interpolazione polinomiale\"}>\n                    <p>\n                        Il <u>teorema fondamentale dell'algebra</u> dice che <b>esiste una sola interpolante <i>polinomiale</i></b> che interpola un dato insieme di punti.\n                    </p>\n                    <p>\n                        Con <ILatex>n+1</ILatex> punti, l'interpolante sarà al massimo di grado <ILatex>n</ILatex>, e viene detta <ILatex>{r`p_n`}</ILatex>.\n                    </p>\n                    <p>\n                        La sua <b>forma canonica</b> sarà:\n                    </p>\n                    <PLatex>{r`p_n(x) = a_0 + a_1 x + a_2 x^2 + a_3 x^3 + \\dots + a_n x^n`}</PLatex>\n                </Panel>\n            </Section>\n            <Section title={\"Metodi di interpolazione\"}>\n                <Panel title={\"Metodo dei coefficienti indeterminati\"}>\n                    <p>\n                        È possibile scrivere la forma canonica come <b>matrice</b>:\n                    </p>\n                    <PLatex>{r`A \\cdot x = b`}</PLatex>\n                    <p>\n                        Costruiamo la <b>matrice di Vandermonde</b>:\n                    </p>\n                    <PLatex>{r`\n                    A =\n                    \\begin{pmatrix}\n                        1 & x_0 & x_0^2 & \\dots & x_0^n\\\\\\\\\n                        1 & x_1 & x_1^2 & \\dots & x_1^n\\\\\\\\\n                        1 & x_2 & x_2^2 & \\dots & x_2^n\\\\\\\\\n                        \\vdots & \\vdots & \\vdots & \\ddots & \\vdots\\\\\\\\\n                        1 & x_n & x_n^2 & \\dots & x_n^n\n                    \\end{pmatrix}\n                    `}</PLatex>\n                    <p>\n                        Costruiamo il <b>vettore delle incognite</b>:\n                    </p>\n                    <PLatex>{r`\n                    x = \n                    \\begin{pmatrix}\n                        a_0\\\\\\\\\n                        a_1\\\\\\\\\n                        a_2\\\\\\\\\n                        \\vdots\\\\\\\\\n                        a_n\n                    \\end{pmatrix}\n                    `}</PLatex>\n                    <p>\n                        Costruiamo il <b>vettore dei termini noti</b>:\n                    </p>\n                    <PLatex>{r`\n                    b =\n                    \\begin{pmatrix}\n                        y_0\\\\\\\\\n                        y_1\\\\\\\\\n                        y_2\\\\\\\\\n                        \\vdots\\\\\\\\\n                        y_n\n                    \\end{pmatrix}\n                    `}</PLatex>\n                    <Example>\n                        Per trovare il polinomio di interpolazione è sufficiente risolvere il problema!\n                    </Example>\n                    <p>\n                        È efficace perchè una volta calcolati i coefficienti essi <b>valgono per tutti i punti</b>, ma ha come svantaggio che la matrice di Vandermonde è <b>spesso malcondizionata.</b>\n                    </p>\n                </Panel>\n                <Panel title={\"Metodo di Lagrange\"}>\n                    <p>\n                        È possibile scrivere il polinomio di interpolazione <b>raccogliendo le <ILatex>{r`y`}</ILatex></b>:\n                    </p>\n                    <PLatex>{r`p_n (x) = y_0 L_0 + y_1 L_1 + y_2 L_2 + \\dots + y_n L_n`}</PLatex>\n                    <p>\n                        I polinomi <ILatex>{r`L_k`}</ILatex> sono detti <b>polinomi di Lagrange</b>, e hanno le seguenti proprietà:\n                    </p>\n                    <ul>\n                        <li>\n                            Valgono <ILatex>1</ILatex> in corrispondenza del nodo con lo stesso indice, <ILatex>0</ILatex> in corrispondenza dei nodi con indice diverso e <ILatex>{r`0 < n < 1`}</ILatex> in tutti gli altri casi.\n\n                            <PLatex>{r`\n                            \\begin{cases}\n                                L_k(x_k) = 1 \\qquad (nel\\ nodo)\\\\\n                                L_k(x_j) = 0 \\qquad (altri\\ nodi)\n                            \\end{cases}\n                        `}</PLatex></li>\n                        <li>\n                            Si compongono con questo prodotto:\n\n                            <PLatex>{r`L_k = \\frac{(x - x_0) \\cdot \\dots \\cdot (x - x_{k-1}) \\cdot (x - x_{k+1}) \\cdot \\dots \\cdot (x_k - x_n)}{(x_k - x_0) \\cdot \\dots \\cdot (x_k - x_{k-1}) \\cdot (x_k - x_{k+1}) \\cdot \\dots \\cdot (x_k - x_n)}`}</PLatex>\n                        </li>\n                    </ul>\n                    <Example>Non c'è il termine con <ILatex>{r`x_k`}</ILatex>!</Example>\n                    <p>\n                        Tutti insieme formano la <b>base di Lagrange</b>.\n                    </p>\n                    <Example>Si chiama base perchè sono <b>linearmente indipendenti</b>!</Example>\n                    <p>\n                        Questo metodo permette di calcolare il valore del polinomio di interpolazione <b>in un singolo punto</b>:\n                    </p>\n                    <Example>\n                        <p>\n                            Si può risparmiare tempo di calcolo calcolando una singola volta il numeratore con <i>tutti</i> i termini:\n                        </p>\n                        <PLatex>{r`\\omega_n = (x - x_0) \\cdot (x - x_1) \\cdot \\dots \\cdot (x - x_n)`}</PLatex>\n                        <p>\n                            E poi dividendo per il termine che andrebbe escluso:\n                        </p>\n                        <PLatex>{r`L_k(x) = \\frac{ \\omega_n }{ (x - x_k) \\cdot \\prod_{i=0, i \\neq k} (x_k - x_i) }`}</PLatex>\n                    </Example>\n                    <p>\n                        Ha costo computazionale <ILatex>{r`O(n^2)`}</ILatex>.\n                    </p>\n                </Panel>\n            </Section>\n            <Section title={\"Resto di interpolazione\"}>\n                <Panel title={\"Definizione\"}>\n                    <p>\n                        È l'<b>errore compiuto durante l'interpolazione</b>.\n                    </p>\n                    <p>\n                        Se la funzione <ILatex>f</ILatex> è interpolata da <ILatex>p_n</ILatex>, allora esso varrà:\n                    </p>\n                    <PLatex>{r`R_n(x) = f(x) - p_n(x)`}</PLatex>\n                    <p>\n                        In particolare, è interessante la sua norma a infinito, <ILatex>{r`\\| f - p_n \\|_\\infty`}</ILatex>, che corrisponde alla distanza massima tra le due funzioni.\n                    </p>\n                    <p>\n                        Un teorema dice che esso è uguale a: <Todo>TODO: Non credo serva.</Todo>\n                    </p>\n                    <PLatex>{r`R_n(x) = \\frac{ \\omega_n(x) }{ (n + 1)! } \\cdot f^{(n+1)}(\\xi)`}</PLatex>\n                </Panel>\n                <Panel title={\"Stima\"}>\n                    <p>\n                        <Todo>TODO: Tutta la dimostrazione di queste due affermazioni.</Todo>\n                    </p>\n                    <p>\n                        L'errore nell'interpolazione dipende principalmente da due fattori:\n                    </p>\n                    <ul>\n                        <li>Come sono <b>distribuiti sull'asse X</b> i punti da interpolare</li>\n                        <li>Il grado del polinomio di interpolazione</li>\n                    </ul>\n                </Panel>\n            </Section>\n            <Section>\n                <Panel title={\"Fenomeno di Runge\"}>\n                    <p>\n                        Fenomeno che si verifica cercando di interpolare la <i>funzione di Runge</i> (<ILatex>{r`\\frac{1}{1 + 25x^2}`}</ILatex>).\n                    </p>\n                    <p>\n                        Scegliendo <b>nodi equispaziati</b>, l'errore di interpolazione sarà <b>enorme</b> vicino ai due estremi dell'intervallo.\n                    </p>\n                    <Example>\n                        Addirittura, più nodi verranno scelti, più esso sarà alto!\n                    </Example>\n                    <p>\n                        Si evita scegliendo i nodi in una maniera diversa.\n                    </p>\n                </Panel>\n                <Panel title={\"Nodi di Chebychev\"}>\n                    <p>\n                        Nodi ottenuti partizionando una <b>semicirconferenza</b>, e proiettando le partizioni sul diametro.\n                    </p>\n                    <p>\n                        La formula usata per ottenere <ILatex>{r`n`}</ILatex> punti è:\n                    </p>\n                    <PLatex>{r`x_i = \\cos \\left( \\frac{ (2 \\cdot i + 1) \\cdot \\pi }{ 2 \\cdot (n+1) } \\right)`}</PLatex>\n                    <p>\n                        <u>Proprietà di min-max</u>: sono la <b>scelta ottimale</b> dei punti di interpolazione.\n                    </p>\n                    <PLatex>{r`\\omega_n(\\star) = \\max_{x \\in [a, b]} \\left| \\omega_n(x) \\right|`}</PLatex>\n                    <p>\n                        In particolare, si ha che:\n                    </p>\n                    <PLatex>{r`\\omega_n(\\star) = 2 \\left( \\frac{b-a}{4} \\right)^{n+1}`}</PLatex>\n                </Panel>\n            </Section>\n        </Fragment>\n    )\n}\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"menulist\":\"menulist__2Cmnq\"};","import style from \"./02_ZeriDiFunzione.less\";\nimport {Fragment} from \"preact\";\nimport {Section, Panel, ILatex, BLatex, PLatex, Todo} from \"bluelib\";\nimport Example from \"../../components/Example\";\n\nconst r = String.raw;\n\n\nexport default function (props) {\n    return (\n        <Fragment>\n            <Section title={\"Problema: Ricerca degli zeri di funzione\"}>\n                <Panel title={\"Descrizione\"}>\n                    <p>\n                        Si vogliono trovare i punti (<i>zeri</i>) in cui una funzione <b>continua</b> <ILatex>f : [a, b] \\to R</ILatex> vale <ILatex>0</ILatex>.\n                    </p>\n                    <p>\n                        Per il <b>teorema del valore medio</b>, se <ILatex>{r`f(a) \\cdot f(b) \\leq 0`}</ILatex>, allora esiste sicuramente un punto in cui la funzione vale 0.\n                    </p>\n                    <p>\n                        Denominiamo il punto in cui la funzione vale <ILatex>0</ILatex> come <ILatex>{r`x_{(\\star)}`}</ILatex>.\n                    </p>\n                </Panel>\n                <Panel title={\"Condizionamento\"}>\n                    <p>\n                        Più la <b>derivata prima</b> della funzione <b>si avvicina allo 0</b>, <b>peggio</b> il problema sarà condizionato.\n                    </p>\n                    <PLatex>{r`f'(x_{(\\star)}) \\simeq 0 \\implies mal\\ condizionato`}</PLatex>\n                </Panel>\n            </Section>\n            <Section>\n                <Panel title={\"Ordine di convergenza\"}>\n                    <p>\n                        Indice <ILatex>{r`{\\color{Orange} p}`}</ILatex> di quanto in fretta una successione converge alla soluzione.\n                    </p>\n                    <PLatex>{r`\\lim_{i \\to +\\infty} \\frac{ \\left| x_{(i+1)} - x_{(\\star)} \\right| }{ \\left| x_{(k)} - x_{(\\star)} \\right|^{\\color{Orange} p}}`}</PLatex>\n                    <ul>\n                        <li><u>Convergenza lineare</u>: <ILatex>{r`p = 1`}</ILatex> e <ILatex>{r`0 < C < 1`}</ILatex></li>\n                        <li><u>Convergenza superlineare</u>: <ILatex>{r`p = 1`}</ILatex> e <ILatex>{r`C = 0`}</ILatex></li>\n                        <li><u>Convergenza quadratica</u>: <ILatex>{r`p = 2`}</ILatex> e <ILatex>{r`0 < C < 1`}</ILatex></li>\n                        <li><u>Convergenza superquadratica</u>: <ILatex>{r`p = 2`}</ILatex> e <ILatex>{r`C = 0`}</ILatex></li>\n                        <li>...</li>\n                    </ul>\n                </Panel>\n            </Section>\n            <Section title={\"Metodi dicotomici\"}>\n                <Panel title={\"Cosa sono?\"}>\n                    <p>\n                        Sono <b>metodi iterativi</b> in grado di ridurre sempre di più l'intervallo in cui è definita la funzione, facendolo convergere allo zero desiderato.\n                    </p>\n                    <p>\n                        Alcuni di essi sono il <i>metodo dicotomico</i> e il <i>metodo regula falsi</i>.\n                    </p>\n                    <p>\n                        Richiedono <b>una valutazione di funzione non-lineare</b> ad ogni iterazione.\n                    </p>\n                    <p>\n                        Ad ogni iterazione, l'intervallo viene sempre <i>almeno</i> <b>dimezzato</b>; si ha, pertanto, che:\n                    </p>\n                    <PLatex>{r`b_{(i)} - a_{(i)} = \\frac{b - a}{2^{i - 1}}`}</PLatex>\n                    <p>\n                        Hanno quindi <b>convergenza lineare</b> (<ILatex>{r`C = \\frac{1}{2}, p = 1`}</ILatex>).\n                    </p>\n                    <p>\n                        Il loro <i>criterio di arresto</i> è un <b>numero di iterazioni prefissato</b> che dipende dalla <b>tolleranza</b> sull'errore:\n                    </p>\n                    <PLatex>{r`i \\geq \\log_2 \\left( \\frac{b - a}{\\tau} \\right)`}</PLatex>\n                    <Example>\n                        Dividi l'intervallo <ILatex>{r`[a, b]`}</ILatex> in tante parti grandi quanto la tolleranza. L'algoritmo di bisezione ne escluderà metà ad ogni iterazione; la tolleranza sarà raggiunta quando rimarrà una parte sola!\n                    </Example>\n                </Panel>\n            </Section>\n            <Section>\n                <Panel title={\"Metodo di bisezione\"}>\n                    <ol>\n                        <li>Finchè non sono state compiute il numero di iterazioni prefissate:\n                            <ol>\n                                <li>\n                                    Calcoliamo il <b>punto medio</b> dell'intervallo <ILatex>{r`[a_{(n)}, b_{(n)}]`}</ILatex>:\n                                    <PLatex>{r`c_{(n)} = a_{(n)} + \\frac{b_{(n)} - a_{(n)}}{2}`}</PLatex>\n                                </li>\n                                <li>\n                                    Dividiamo l'intervallo in due parti, separate da <ILatex>{r`c_{(n)}`}</ILatex>:\n                                    <ul>\n                                        <li><ILatex>{r`[a_{(n)}, c_{(n)}]`}</ILatex> è la <b>metà</b> sinistra</li>\n                                        <li><ILatex>{r`[c_{(n)}, b_{(n)}]`}</ILatex> è la <b>metà</b> destra</li>\n                                    </ul>\n                                </li>\n                                <li>\n                                    Teniamo l'intervallo in cui i valori della funzione ai due estremi sono discordi, e rinominiamolo in <ILatex>{r`[a_{(n+1)}, b_{(n+1)}]`}</ILatex>.\n                                </li>\n                            </ol>\n                        </li>\n                    </ol>\n                </Panel>\n                <Panel title={\"Metodo regula falsi\"}>\n                    <ol>\n                        <li>Finchè non sono state compiute il numero di iterazioni prefissate:\n                            <ol>\n                                <li>\n                                    Calcoliamo l'<b>intersezione</b> tra la <b>retta che congiunge i due estremi</b> <ILatex>{r`a_{(n)}, b_{(n)}`}</ILatex> e l'<b>asse X</b>:\n                                    <PLatex>{r`c_{(n)} = b_{(n)} - \\frac{f(b_{(n)})}{\\frac{f(b_{(n)}) - f(a_{(n)})}{b_{(n)} - a_{(n)}}}`}</PLatex>\n                                </li>\n                                <li>\n                                    Dividiamo l'intervallo in due parti, separate da <ILatex>{r`c_{(n)}`}</ILatex>:\n                                    <ul>\n                                        <li><ILatex>{r`[a_{(n)}, c_{(n)}]`}</ILatex> è la parte sinistra</li>\n                                        <li><ILatex>{r`[c_{(n)}, b_{(n)}]`}</ILatex> è la parte destra</li>\n                                    </ul>\n                                </li>\n                                <li>\n                                    Teniamo l'intervallo in cui i valori della funzione ai due estremi sono discordi, e rinominiamolo in <ILatex>{r`[a_{(n+1)}, b_{(n+1)}]`}</ILatex>.\n                                </li>\n                            </ol>\n                        </li>\n                    </ol>\n                </Panel>\n            </Section>\n            <Section title={\"Metodo delle approssimazioni successive\"}>\n                <Panel title={\"Metodi delle approssimazioni successive\"}>\n                    <p>\n                        Sono <b>metodi iterativi</b> che funzionano in modo molto simile ai metodi iterativi per i sistemi lineari, utilizzando una funzione <ILatex>{r`\\phi`}</ILatex> come \"metodo\".\n                    </p>\n                    <PLatex>{r`x = x - \\phi(x) \\cdot f(x)`}</PLatex>\n                    <p>\n                        Che diventa:\n                    </p>\n                    <PLatex>{r`x_{(k+1)} = g( x_{(k)} )`}</PLatex>\n                    <p>\n                        Sfruttano i <b>punti fissi</b> <ILatex>{r`g(x_{(\\star)}) = x_{(\\star)}`}</ILatex> della funzione <ILatex>{r`f`}</ILatex> per convergere:<br/>\n                        se <ILatex>{r`\\phi(x)`}</ILatex> non ha zeri, allora i punti fissi <b>coincideranno</b> con gli <b>zeri</b> della funzione <ILatex>{r`f`}</ILatex>.\n                    </p>\n                    <PLatex>{r`g(x) = x - \\phi(x) \\cdot f(x)`}</PLatex>\n                    <p>\n                        Si può raggiungere iterativamente ad un punto fisso attraverso la formula:\n                    </p>\n                    <PLatex>{r`x_{(k+1)} = g( x_{(k)} )`}</PLatex>\n                    <p>\n                        Non si conosce in anticipo il numero di iterazioni necessarie per soddisfare la tolleranza <ILatex>{r`\\tau`}</ILatex>; ad ogni iterazione, si controlla se la tolleranza è soddisfatta:\n                    </p>\n                    <ul>\n                        <li>Nella differenza tra due iterate: <ILatex>{r`\\frac{\\left| x_{(k+1)} - x_{(k)} \\right|}{\\left| x_{(k+1)} \\right|} \\leq \\tau`}</ILatex></li>\n                        <li>Nel <i>residuo</i> del problema: <ILatex>{r`\\left| f(x_{(k)}) \\right| \\leq \\tau`}</ILatex></li>\n                    </ul>\n                </Panel>\n                <Panel title={\"Teorema della mappa contrattiva\"}>\n                    <p>\n                        Se:\n                    </p>\n                    <ul>\n                        <li>\n                            Tutti i valori restituiti dalla funzione <ILatex>{r`g`}</ILatex> rientrano nel suo stesso dominio:\n                            <PLatex>{r`g : [a, b] \\to [a, b]`}</PLatex>\n                        </li>\n                        <li>\n                            <p>\n                                La funzione <ILatex>{r`g`}</ILatex> è una contrazione, ovvero restringe l'intervallo <ILatex>{r`[a, b]`}</ILatex>:\n                            </p>\n                            <PLatex>{r`\\forall (x, y) \\in [a, b], | g(x) - g(y) | \\leq L \\cdot | x - y |`}</PLatex>\n                            <p>\n                                (dove <ILatex>{r`0 < L < 1`}</ILatex>)\n                            </p>\n                        </li>\n                    </ul>\n                    <p>\n                        Allora:\n                    </p>\n                    <ul>\n                        <li>\n                            <p>\n                                Il punto fisso esiste ed è unico:\n                            </p>\n                            <PLatex>{r`\\exists! x_{(\\star)}`}</PLatex>\n                        </li>\n                        <li>\n                            Il metodo delle approssimazioni successive converge per qualsiasi punto di partenza.\n                        </li>\n                        <li>\n                            <p>\n                                Vale la seguente disequazione di <i>maggiorazione dell'errore</i>:\n                            </p>\n                            <PLatex>{r`\\left| x_{(k)} - x_{(\\star)} \\right| \\leq \\frac{ L^k }{ 1 - L } \\cdot \\left| x_{(1)} - x_{(0)} \\right|`}</PLatex>\n                        </li>\n                    </ul>\n                    <p>\n                        Più è piccolo <ILatex>L</ILatex>, più il metodo convergerà in fretta.\n                    </p>\n                    <Example>\n                        <ILatex>L</ILatex> è molto simile al raggio spettrale <ILatex>{r`\\rho(M)`}</ILatex> dei metodi iterativi per i sistemi lineari!\n                    </Example>\n                </Panel>\n            </Section>\n            <Section>\n                <Panel title={\"Metodo di Newton\"}>\n                    <p>\n                        Sfrutta la <b>continuità</b> delle funzioni per ottenere una convergenza di ordine più alto.\n                    </p>\n                    <PLatex>{r`\\phi (x) = \\frac{1}{f' (x)}`}</PLatex>\n                    <PLatex>{r`x_{(k+1)} = x_{(k)} - \\frac{ f(x_{(k)}) }{ f'(x_{(k)}) }`}</PLatex>\n                    <Example>\n                        Geometricamente, corrisponde a prolungare una retta nel punto <ILatex>{r`(x_{(k)}, f(x_{(k)}))`}</ILatex> con pendenza <ILatex>{r`f'(x_{(k)})`}</ILatex>, e prendendo come nuovo punto la sua intersezione con l'asse X e la sua corrispettiva immagine nella funzione.\n                    </Example>\n                    <p>\n                        Ha costo computazionale di <b>2 valutazioni di funzione</b> più <b>2 valutazioni di derivata</b>.\n                    </p>\n                    <p>\n                        Ha <b>convergenza quadratica</b>.\n                    </p>\n                </Panel>\n                <Panel title={\"Metodo delle secanti\"}>\n                    <p>\n                        È come il metodo di Newton, ma usa il <b>rapporto incrementale</b>, in modo da poter essere applicato a funzioni non continue.\n                    </p>\n                    <PLatex>{r`\\phi (x) = \\frac{ 1 }{ \\frac{ f(x_{(k)}) - f(x_{(k-1)}) }{ x_{(k)} - x_{(k-1)} } }`}</PLatex>\n                    <PLatex>{r`x_{(k+1)} = x_{(k)} - \\frac{ f(x_{(k)}) }{ \\frac{ f(x_{(k)}) - f(x_{(k-1)}) }{ x_{(k)} - x_{(k-1)} } }`}</PLatex>\n                    <Example>\n                        Geometricamente, corrisponde a costruire una retta che attraversa i punti <ILatex>{r`(x_{(k)}, f(x_{(k)}))`}</ILatex> e <ILatex>{r`(x_{(k-1)}, f(x_{(k-1)}))`}</ILatex>, e prendendo come nuovo punto la sua intersezione con l'asse X e la sua corrispettiva immagine nella funzione.\n                    </Example>\n                    <p>\n                        Ha costo computazionale di <b>3 valutazioni di funzione</b>.\n                    </p>\n                    <p>\n                        Ha <b>convergenza superlineare</b>.\n                    </p>\n                </Panel>\n            </Section>\n            <Section>\n                <Panel title={\"Approssimare sistemi non-lineari\"}>\n                    <p>\n                        È possibile usare questi metodi per <b>approssimare le soluzioni di sistemi non-lineari</b>.\n                    </p>\n                </Panel>\n            </Section>\n        </Fragment>\n    )\n}\n","import style from \"./Box.less\";\nimport concatClass from \"../../utils/concatClass\";\n\nexport const BoxColors = Object.freeze({\n    RED: style.red,\n    ORANGE: style.orange,\n    YELLOW: style.yellow,\n    LIME: style.lime,\n    CYAN: style.cyan,\n    BLUE: style.blue,\n    MAGENTA: style.magenta,\n    DEFAULT: style.default\n})\n\nexport default function (props) {\n    let color = BoxColors.DEFAULT;\n    if(props.color) {\n        color = props.color;\n    }\n\n    return (\n        <div class={concatClass(style.box, color, props.class)}>\n            {props.children}\n        </div>\n    );\n}\n","import { createContext } from 'preact';\n\nexport default createContext(undefined);\n","import {createContext} from \"preact\";\n\nexport default createContext(\"White\");\n","import {createContext} from \"preact\";\n\nexport default createContext(true);\n","import {createContext} from \"preact\";\n\nexport default createContext(null);\n","import {createContext} from \"preact\";\n\nexport default createContext(undefined);\n","import { createContext } from 'preact';\n\nexport default createContext(null);\n","// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error\nclass RoyalnetApiError extends Error {\n    constructor(errorCode, errorType, errorArgs, ...params) {\n        // noinspection JSCheckFunctionSignatures\n        super(...params);\n        if(Error.captureStackTrace) Error.captureStackTrace(this, RoyalnetApiError);\n\n        this.name = \"RoyalnetApiError\";\n        this.errorCode = errorCode;\n        this.errorType = errorType;\n        this.errorArgs = errorArgs;\n        this.message = `${errorCode} | ${errorType} | ${errorArgs.join(\"|\")}`;\n    }\n}\n\n\nasync function royalnetApiRequest(baseUrl, method, path, args, abortSignal) {\n    if(args === undefined || args === null) {\n        args = {};\n    }\n\n    let body;\n    let url;\n    if(method === \"GET\") {\n        body = undefined;\n        //Create a query string\n        let params = new URLSearchParams();\n        //Use the items in the args object as key-value pairs for the query string\n        Object.keys(args).forEach(key => {\n            let arg = args[key];\n            params.append(key, arg);\n        });\n        url = `${baseUrl}${path}?${params.toString()}`;\n    }\n    else {\n        body = JSON.stringify(args);\n        url = `${baseUrl}${path}`;\n    }\n\n    //Make the request\n    let response = await fetch(url, {\n        method: method,\n        body: body,\n        signal: abortSignal,\n    });\n    //Parse the response as JSON\n    let json = await response.json();\n    //Check if the request was a success\n    if(json[\"success\"] === false) {\n        throw new RoyalnetApiError(json[\"error_code\"], json[\"error_type\"], json[\"error_args\"])\n    }\n    return json[\"data\"]\n}\n\nexport {royalnetApiRequest, RoyalnetApiError};\n","import style from \"./04_InterpolazioneATratti.less\";\nimport {Fragment} from \"preact\";\nimport {Section, Panel, ILatex, BLatex, PLatex, Todo} from \"bluelib\";\nimport Example from \"../../components/Example\";\n\nconst r = String.raw;\n\n\nexport default function (props) {\n    return (\n        <Fragment>\n            <Section title={\"Problema: Interpolazione a tratti\"}>\n                <Panel title={\"Come funziona?\"}>\n                    <p>\n                        Invece che costruire una singola funzione che interpola tutti i punti, per <b>ogni intervallo tra due punti</b> (<i>sottointervallo</i>) si costruisce <b>una funzione apposta</b>.\n                    </p>\n                </Panel>\n            </Section>\n            <Section title={\"Splines\"}>\n                <Panel title={\"Cosa sono?\"}>\n                    <p>\n                        Interpolanti che:\n                    </p>\n                    <ul>\n                        <li>sono <b>polinomiali</b> di grado massimo <ILatex>{r`n`}</ILatex></li>\n                        <li>sono <b>continue</b> fino al grado <ILatex>{r`n - 1`}</ILatex></li>\n                        <li>connettono <ILatex>{r`m + 2`}</ILatex> punti, e hanno <ILatex>{r`m`}</ILatex> sottointervalli</li>\n                        <li>hanno funzioni <b>definite appositamente</b> per ogni sottointervallo</li>\n                    </ul>\n                    <Example>\n                        <p>\n                            Significa che agli estremi dell'intervallo, i valori di tutte le derivate fino al grado <ILatex>{r`n - 1`}</ILatex> devono essere uguali:\n                        </p>\n                        <PLatex>{r`\\forall \\ k \\leq n-1, \\forall \\ i \\in \\{intervalli\\}, \\quad s_i^{(k)} (x_{i+1}) = s_i^{(k)} (x_{i+1})`}</PLatex>\n                    </Example>\n                    <p>\n                        Hanno <ILatex>{r`n + m + 1`}</ILatex> gradi di libertà.\n                    </p>\n                    <Example>\n                        Esistono infinite spline di grado <ILatex>{r`n \\geq 2`}</ILatex>!\n                    </Example>\n                </Panel>\n            </Section>\n            <Section>\n                <Panel title={\"Spline lineari\"}>\n                    <Example>\n                        Sono anche dette <b>interpolanti lineari a tratti</b>.\n                    </Example>\n                    <p>\n                        Per ogni sottointervallo, costruiamo una <b>funzione lineare</b> passante per i due estremi:\n                    </p>\n                    <PLatex>{r`s_i(x) = y_i + \\frac{ y_{i + 1} - y_i }{ x_{i + 1} - x_i } \\cdot (x - x_i)`}</PLatex>\n                    <Example>\n                        È una linea spezzata!\n                    </Example>\n                    <p>\n                        Il loro errore è:\n                    </p>\n                    <PLatex>{r`\\| R \\|_\\infty = \\| f - s \\|_\\infty \\leq \\frac{1}{8} \\cdot \\max_{y \\in [a, b]} \\left| f''(y) \\right| \\cdot \\left( \\max_{i \\in \\{intervalli\\}} (x_{i+1} - x_{i}) \\right)^2`}</PLatex>\n                    <p>\n                        Ha come vantaggi complessità computazionale <b>molto più bassa</b> e l'<b>assenza</b> del fenomeno di Runge, ma allo stesso tempo si <b>perde la derivabilità della funzione.</b>\n                    </p>\n                    <p>\n                        <b>Non</b> hanno gradi di libertà.\n                    </p>\n                </Panel>\n                <Panel title={\"Spline cubiche\"}>\n                    <p>\n                        Spline con <ILatex>{r`n = 3`}</ILatex>, che soddisfano le seguenti uguaglianze:\n                    </p>\n                    <PLatex>{r`\n                    \\forall \\ i \\in \\{0,\\ \\dots\\ ,\\ m - 1\\},\\ \n                    \\begin{cases}\n                        s_i (x_{i+1}) = s_{i+1} (x_{i+1})\\\\\\\\\n                        s'_i (x_{i+1}) = s'_{i+1} (x_{i+1})\\\\\\\\\n                        s''_i (x_{i+1}) = s''_{i+1} (x_{i+1})\n                    \\end{cases}                    \n                    `}</PLatex>\n                    <PLatex>{r`\n                    \\forall \\ i \\in \\{0,\\ \\dots\\ ,\\ m + 1\\},\\ \n                    \\begin{cases}\n                        s_i(x_i) = y_i\n                    \\end{cases}\n                    `}</PLatex>\n                    <p>\n                        Esse hanno la seguente equazione:\n                    </p>\n                    <PLatex>{r`s_i(x) = \\alpha_i + \\beta_i \\ ( x - x_i ) + \\gamma_i \\ ( x - x_i )^2 + \\delta_i \\ ( x - x_i )^3`}</PLatex>\n                    <Example>\n                        Spesso si indica con <ILatex>{r`h`}</ILatex> la distanza orizzontale tra due punti di un sottointervallo.\n                    </Example>\n                </Panel>\n            </Section>\n            <Section>\n                <Panel title={\"Spline cubica vincolata\"}>\n                    <p>\n                        Classe di spline cubiche in cui:\n                    </p>\n                    <ul>\n                        <li><ILatex>{r`\\beta_0`}</ILatex> e <ILatex>{r`\\beta_{m+1}`}</ILatex> sono prefissati</li>\n                    </ul>\n                    <p>\n                        È <b>unica</b>.\n                    </p>\n                    <p>\n                        Forma il seguente sistema di equazioni:\n                    </p>\n                    <PLatex>{r`T z = c`}</PLatex>\n                    <PLatex>{r`\n                        b_i = h_{i+1} \\beta_i + 2 ( h_i + h_{i+1} ) + h_{i} \\beta_i+2\n                    `}</PLatex>\n                    <PLatex>{r`\n                        T = \n                        \\begin{pmatrix}\n                            2 (h_0 + 2 h_1) & h_0 & {\\color{Gray} 0} & {\\color{Gray} 0} & {\\color{Gray} 0} \\\\\\\\\n                            h_2 & 2 (h_1 + h_2) & h_1 & {\\color{Gray} 0} & {\\color{Gray} 0} \\\\\\\\\n                            {\\color{Gray} 0} & \\ddots & \\ddots & \\ddots & {\\color{Gray} 0} \\\\\\\\\n                            {\\color{Gray} 0} & {\\color{Gray} 0} & h_{m-1} & 2 (h_{m-2} + h_{m-1}) & h_{m-2} \\\\\\\\\n                            {\\color{Gray} 0} & {\\color{Gray} 0} & {\\color{Gray} 0} & h_m & 2 (h_{m-1} + h_m)\n                        \\end{pmatrix}\n                    `}</PLatex>\n                    <PLatex>{r`\n                        z =\n                        \\begin{pmatrix}\n                            \\beta_1\\\\\\\\\n                            \\beta_2\\\\\\\\\n                            \\vdots\\\\\\\\\n                            \\beta_{m-1}\\\\\\\\\n                            \\beta_{m}\n                        \\end{pmatrix}\n                    `}</PLatex>\n                    <PLatex>{r`\n                        c =\n                        \\begin{pmatrix}\n                            b_0 - h_1 \\beta_0\\\\\\\\\n                            b_1\\\\\\\\\n                            \\vdots\\\\\\\\\n                            b_{m-2}\\\\\\\\\n                            b_{m-1} - h_{m-1} \\beta_{m+1}\n                        \\end{pmatrix}\n                    `}</PLatex>\n                </Panel>\n            </Section>\n            <Section>\n                <Panel title={\"Spline cubica naturale\"}>\n                    <p>\n                        Classe di spline cubiche in cui:\n                    </p>\n                    <ul>\n                        <li><ILatex>{r`s''(x_0) = s''(x_{m+1}) = 0`}</ILatex></li>\n                    </ul>\n                    <p>\n                        È <b>unica</b>.\n                    </p>\n                </Panel>\n                <Panel title={\"Spline cubica periodica\"}>\n                    <p>\n                        Classe di spline cubiche in cui:\n                    </p>\n                    <ul>\n                        <li><ILatex>{r`s(x) = s(m+1)`}</ILatex></li>\n                        <li><ILatex>{r`s'(x) = s'(m+1)`}</ILatex></li>\n                        <li><ILatex>{r`s''(x) = s''(m+1)`}</ILatex></li>\n                    </ul>\n                    <p>\n                        È <b>unica</b>.\n                    </p>\n                </Panel>\n                <Panel title={\"Spline cubica not-a-knot\"}>\n                    <p>\n                        Classe di spline cubiche in cui:\n                    </p>\n                    <ul>\n                        <li>Negli intervalli <ILatex>{r`[x_0, x_2]`}</ILatex> e <ILatex>{r`[x_{m-1}, x_{m+1}]`}</ILatex> si presenta <b>obbligatoriamente</b> un polinomio di <b>grado 3</b>.</li>\n                    </ul>\n                    <p>\n                        È <b>unica</b>.\n                    </p>\n                </Panel>\n            </Section>\n            <Section>\n                <Panel title={\"Proprietà di minima curvatura\"}>\n                    <p>\n                        Tra tutte le funzioni che interpolano dei punti, le tre classi di funzioni sopraelencate sono quelle che interpolano la funzione più \"dolcemente\".\n                    </p>\n                    <p>\n                        Per loro è valida la seguente proprietà:\n                    </p>\n                    <PLatex>{r`\\int_a^b ( s''(x) )^2 dx \\leq \\int_a^b ( f''(x) )^2 dx`}</PLatex>\n                </Panel>\n                <Panel title={\"Errore di interpolazione\"}>\n                    <p>\n                        Più diminuisce la lunghezza <ILatex>{r`h`}</ILatex> degli intervalli, più aumenta l'accuratezza.\n                    </p>\n                    <p>\n                        <b>Non</b> si verifica il fenomeno di Runge.\n                    </p>\n                    <p>\n                        Si ha un'interpolazione anche della <b>derivata prima</b>.\n                    </p>\n                </Panel>\n            </Section>\n        </Fragment>\n    )\n}\n","import style from \"./MenuList.less\";\n\nexport default function(props) {\n    return (\n        <ul class={style.menulist}>\n            {props.children}\n        </ul>\n    )\n}","import style from \"./Example.less\";\n\nexport default function (props) {\n    return (\n        <div class={style.example}>\n            {props.children}\n        </div>\n    );\n}\n","import style from \"./01_SistemiLineari.less\"\nimport {ILatex, Panel, PLatex, Section, Todo} from \"bluelib\";\nimport Link from \"../../components/Link\";\nimport Example from \"../../components/Example\";\nimport {Fragment} from \"preact\";\n\nconst r = String.raw;\n\n\nexport default function () {\n    return (\n        <Fragment>\n            <Section title={\"Problema: Risoluzione di sistemi lineari\"}>\n                <Panel title={\"Descrizione\"}>\n                    <p>\n                        Dato un sistema di equazioni lineari, si vuole trovare la sua soluzione.\n                    </p>\n                    <p>\n                        In forma matriciale, avrà una <b>matrice dei coefficienti</b> <ILatex>{r`A`}</ILatex>, un <b>vettore dei termini noti</b> <ILatex>{r`b`}</ILatex> e un <b>vettore delle incognite</b> <ILatex>{r`x`}</ILatex>.\n                    </p>\n                    <p>\n                        L'equazione matriciale del sistema è:\n                    </p>\n                    <PLatex>{r`A \\cdot x = b`}</PLatex>\n                </Panel>\n                <Panel title={\"Condizionamento\"}>\n                    <p>\n                        Il condizionamento della risoluzione di sistemi lineari è:\n                    </p>\n                    <PLatex>{r`\\frac{{\\color{yellow} \\|A\\| \\cdot \\|A^{-1}\\|} \\cdot \\| \\Delta b \\|}{\\| b \\|}`}</PLatex>\n                    <p>\n                        In particolare, è segnato in giallo nella formula il <b>numero di condizionamento</b>:\n                    </p>\n                    <PLatex>\n                        {r`k(A) = \\| A \\| \\cdot \\| A^{-1} \\|`}\n                    </PLatex>\n                </Panel>\n            </Section>\n            <Section>\n                <Panel title={\"Metodi diretti\"}>\n                    <p>\n                        Metodi che trovano la soluzione esatta<abbr title={\"Per quanto possibile nell'algebra di macchina.\"}>*</abbr> di un sistema lineare.\n                    </p>\n                    <p>\n                        Tipicamente prevedono la <b>fattorizzazione</b> della matrice dei coefficienti in due sottomatrici più facili da risolvere.\n                    </p>\n                    <p>\n                        Generalmente hanno una complessità temporale <ILatex>{r`O(n^3)`}</ILatex>.\n                    </p>\n                </Panel>\n                <Panel title={\"Metodi iterativi\"}>\n                    <p>\n                        Metodi che trovano una soluzione imperfetta<abbr title={\"Che però può essere la migliore ottenibile, considerando la precisione di macchina.\"}>*</abbr> di un sistema lineare.\n                    </p>\n                    <p>\n                        Tipicamente prevedono l'applicazione ripetuta di un <b>metodo</b>, in base al quale cambia la <b>velocità di convergenza</b> alla soluzione.\n                    </p>\n                    <p>\n                        Generalmente hanno una complessità temporale <ILatex>{r`O(n^2)`}</ILatex>.\n                    </p>\n                </Panel>\n            </Section>\n            <Section title={\"Metodi diretti\"}>\n                <Panel title={\"Divisione\"}>\n                    <p>\n                        Se la matrice dei coefficienti del sistema è <b>diagonale</b>, allora è possibile trovare la soluzione <i>dividendo</i> ogni termine noto per l'unico coefficiente diverso da zero presente nella sua riga:\n                    </p>\n                    <PLatex>{r`x_i = \\frac{b_i}{A_{ii}}`}</PLatex>\n                </Panel>\n                <Panel title={\"Sostituzione\"}>\n                    <p>\n                        Se la matrice dei coefficienti del sistema è <b>triangolare</b> inferiore o superiore, allora è possibile trovare la soluzione effettuando una <i>sostituzione</i> all'avanti oppure all'indietro:\n                    </p>\n                    <PLatex>{r`x_i = \\frac{b_i - \\sum_{k = 1}^{i - 1} (x_k \\cdot A_{ik})}{A_{ii}}`}</PLatex>\n                    <PLatex>{r`x_i = \\frac{b_i - \\sum_{k = i - 1}^{n} (x_k \\cdot A_{ik})}{A_{ii}}`}</PLatex>\n                </Panel>\n            </Section>\n            <Section>\n                <Panel title={<span>Fattorizzazione <ILatex>{r`LU`}</ILatex></span>}>\n                    <p>\n                        Se tutti i valori sulla diagonale di <ILatex>{r`A`}</ILatex> sono <b>diversi da 0 <small>(eccetto l'ultimo)</small></b> allora è possibile <i>fattorizzarla</i> in due matrici: una <ILatex>{r`L`}</ILatex> <b>triangolare inferiore</b>, e una <ILatex>{r`U`}</ILatex> <b>triangolare superiore</b>.\n                    </p>\n                    <PLatex>{r`A = L \\cdot U`}</PLatex>\n                    <Example>\n                        Abbiamo fatto questo metodo in Algebra Lineare, chiamandolo <b>metodo di Gauss</b>.\n                    </Example>\n                    <p>\n                        La matrice <ILatex>{r`L`}</ILatex> è così composta:\n                    </p>\n                    <PLatex>{r`\n                        \\begin{cases}\n                            L_{ii} = 1 \\qquad \\qquad (diagonale)\\\\\n                            L_{ik} = -\\frac{A_{ik}}{A_{kk}} \\qquad (tri.\\ infer.)\n                        \\end{cases}\n                    `}</PLatex>\n                    <Example>\n                        Sono i moltiplicatori usati per rendere annullare il triangolo inferiore!\n                    </Example>\n                    <p>\n                        La matrice <ILatex>{r`U`}</ILatex> è così composta:\n                    </p>\n                    <PLatex>{r`\n                        \\begin{cases}\n                            U_{ik} = A_{ik} \\quad se\\ i \\leq k \\quad (tri.\\ super.)\\\\\n                            U_{ik} = 0 \\qquad se\\ i > k \\quad (tri.\\ infer.)\n                        \\end{cases}\n                    `}</PLatex>\n                    <Example>\n                        È la parte triangolare superiore di <ILatex>{r`A`}</ILatex>!\n                    </Example>\n                    <p>\n                        Il sistema può essere poi risolto applicando due volte il metodo di sostituzione (all'avanti e all'indietro):\n                    </p>\n                    <PLatex>{r`\n                        \\begin{cases}\n                            L \\cdot y = b\\\\\n                            U \\cdot x = y\n                        \\end{cases}\n                    `}</PLatex>\n                    <p>\n                        Questo metodo ha costo computazionale:\n                    </p>\n                    <PLatex>{r`{\\color{Yellow} O\\left(\\frac{n^3}{3}\\right)} + 2 \\cdot O\\left(\\frac{n^2}{2}\\right)`}</PLatex>\n                </Panel>\n                <Panel title={<span>Fattorizzazione <ILatex>{r`LU`}</ILatex> con pivoting parziale</span>}>\n                    <p>\n                        È possibile applicare la fattorizzazione <ILatex>{r`LU`}</ILatex> a <b>qualsiasi matrice non-singolare</b> permettendo lo scambio (<i>pivoting</i>) delle righe, potenzialmente <b>aumentando la stabilità</b> dell'algoritmo.\n                    </p>\n                    <Example>\n                        Abbiamo fatto questo metodo in Algebra Lineare, chiamandolo <b>metodo di Gauss-Jordan</b>!\n                    </Example>\n                    <p>\n                        Alla formula precedente si aggiunge una <b>matrice di permutazione</b> che indica quali righe sono state scambiate:\n                    </p>\n                    <PLatex>{r`P \\cdot A = L \\cdot U`}</PLatex>\n                    <p>\n                        Per massimizzare la stabilità, si cerca di <b>usare come perno l'elemento più grande</b> della colonna.\n                    </p>\n                    <p>\n                        Questo metodo ha costo computazionale:\n                    </p>\n                    <PLatex>{r`{\\color{Yellow} O\\left(\\frac{n^2}{2}\\right)} + O\\left(\\frac{n^3}{3}\\right) + 2 \\cdot O\\left(\\frac{n^2}{2}\\right)`}</PLatex>\n                </Panel>\n                <Panel title={<span>Fattorizzazione <ILatex>{r`LU`}</ILatex> con pivoting totale</span>}>\n                    <p>\n                        È possibile anche permettere il <i>pivoting</i> <b>sulle colonne</b> per <b>aumentare ulteriormente la stabilità</b> dell'algoritmo, a costo di maggiore costo computazionale:\n                    </p>\n                    <PLatex>{r`P \\cdot A \\cdot Q = L \\cdot U`}</PLatex>\n                    <p>\n                        Per massimizzare la stabilità, si cerca di <b>ordinare in modo decrescente la diagonale</b>, assicurandoci che il primo perno sia più grande del secondo e così via.\n                    </p>\n                    <p>\n                        Questo metodo ha costo computazionale:\n                    </p>\n                    <PLatex>{r`{\\color{Yellow} O\\left(\\frac{n^3}{3}\\right)} + O\\left(\\frac{n^3}{3}\\right) + 2 \\cdot O\\left(\\frac{n^2}{2}\\right)`}</PLatex>\n                </Panel>\n            </Section>\n            <Section>\n                <Panel title={<span>Fattorizzazione <ILatex>{r`LU`}</ILatex> a banda</span>}>\n                    <p>\n                        Se la matrice <ILatex>{r`A`}</ILatex> è <b>a banda</b>, è possibile risparmiare spazio durante la fattorizzazione, in quanto sia <ILatex>{r`L`}</ILatex> sia <ILatex>{r`U`}</ILatex> saranno a banda!\n                    </p>\n                </Panel>\n                <Panel title={<span>Fattorizzazione <ILatex>{r`LU`}</ILatex> sparsa</span>}>\n                    <p>\n                        Se la matrice <ILatex>{r`A`}</ILatex> è <b>sparsa</b>, non è detto che <ILatex>{r`L`}</ILatex> e <ILatex>{r`U`}</ILatex> siano sparse a loro volta.\n                    </p>\n                    <p>\n                        Per evitare il <u>fill-in</u>, è necessario <b>riordinare</b> la matrice <ILatex>{r`A`}</ILatex> in modo che sia il più possibile simile a una matrice a banda. <Todo>TODO: Confermare?</Todo>\n                    </p>\n                </Panel>\n            </Section>\n            <Section>\n                <Panel title={<span>Fattorizzazione <ILatex>{r`LDL^{-1}`}</ILatex></span>}>\n                    <p>\n                        È possibile <b>ridurre la complessità computazionale</b> della fattorizzazione <ILatex>{r`LU`}</ILatex> se la matrice dei coefficienti è <b>simmetrica</b>:\n                    </p>\n                    <PLatex>{r`A = L \\cdot D \\cdot L^{-1}`}</PLatex>\n                    <p>\n                        In questo caso, si calcola solo la matrice L, utilizzando il <b>metodo di pavimentazione</b>.\n                    </p>\n                    <PLatex>{r`\n                        \\begin{cases}\n                            d_{ii} = A_{ii} - \\sum_{k=1}^{i-1} ( d_{kk} \\cdot (l_{jk})^2 )\\\\\n                            \\\\\n                            l_{ij} = \\frac{A_{ij} - \\sum_{k=1}^{j-1} l_{ik} \\cdot d_{kk} \\cdot l_{jk}}{d_{ii}}\n                        \\end{cases}\n                    `}</PLatex>\n                    <Example>\n                        <p>\n                            La prima colonna della matrice sarà:\n                        </p>\n                        <PLatex>{r`\n                            \\begin{cases}\n                                d_{11} = A_{11}\\\\\n                                \\\\\n                                l_{i1} = \\frac{A_{i1}}{d_{11}}\n                            \\end{cases}\n                        `}</PLatex>\n                        <p>\n                            La seconda colonna della matrice sarà:\n                        </p>\n                        <PLatex>{r`\n                            \\begin{cases}\n                                d_{22} = A_{22} - d_{11} \\cdot (l_{21})^2\\\\\n                                \\\\\n                                l_{i2} = \\frac{A_{i2} - l_{i1} \\cdot d_{11} \\cdot l_{21}}{d_{ii}}\n                            \\end{cases}\n                        `}</PLatex>\n                    </Example>\n                    <p>\n                        Questo metodo ha costo computazionale:\n                    </p>\n                    <PLatex>{r`{\\color{Yellow} O\\left(\\frac{n^3}{6}\\right)} + O\\left(\\frac{n^3}{3}\\right) + 2 \\cdot O\\left(\\frac{n^2}{2}\\right)`}</PLatex>\n                </Panel>\n                <Panel title={<span>Fattorizzazione <ILatex>{r`\\mathcal{L} \\mathcal{L}^{-1}`}</ILatex></span>}>\n                    <p>\n                        È possibile dare <b>stabilità forte</b> alla fattorizzazione <ILatex>{r`LDL^{-1}`}</ILatex> se la matrice dei coefficienti è <b>simmetrica definita positiva</b>:\n                    </p>\n                    <PLatex>{r`A = \\mathcal{L} \\cdot \\mathcal{L}^{-1}`}</PLatex>\n                    <p>\n                        Il <b>metodo di pavimentazione</b> diventa:\n                    </p>\n                    <PLatex>{r`\n                        \\begin{cases}\n                            l_{ii} = \\sqrt{A_{ii} - \\sum_{k=1}^{i-1}  (l_{ik})^2 }\\\\\n                            \\\\\n                            l_{ij} = \\frac{A_{ij} - \\sum_{k=1}^{j-1} l_{ik} \\cdot l_{jk}}{l_{ii}}\n                        \\end{cases}\n                    `}</PLatex>\n                    <p>\n                        Questo metodo ha costo computazionale:\n                    </p>\n                    <PLatex>{r`O\\left(\\frac{n^3}{3}\\right) + O\\left(\\frac{n^3}{3}\\right) + 2 \\cdot O\\left(\\frac{n^2}{2}\\right)`}</PLatex>\n                </Panel>\n            </Section>\n            <Section>\n                <Panel title={\"Trasformazione di Householder\"}>\n                    <p>\n                        Matrice ricavata dalla seguente formula, dove <ILatex>{r`v`}</ILatex> è la colonna di un'altra matrice:\n                    </p>\n                    <PLatex>{r`U(v) = \\mathbf{I} - \\frac{2 \\cdot v \\cdot v^T}{\\| v \\|_{(2)}^2}`}</PLatex>\n                    <p>\n                        Se moltiplicata per per la matrice da cui proviene <ILatex>{r`v`}</ILatex>, sostituirà la colonna <ILatex>{r`v`}</ILatex> con la colonna:\n                    </p>\n                    <PLatex>{r`\n                        \\begin{pmatrix}\n                            - \\| v \\|\\\\\\\\\n                            0\\\\\\\\\n                            0\\\\\\\\\n                            \\vdots\\\\\\\\\n                            0\n                        \\end{pmatrix}\n                    `}</PLatex>\n                    <p>\n                        Si calcola con una complessità computazionale nell'ordine di <ILatex>{r`O(n)`}</ILatex>.\n                    </p>\n                </Panel>\n                <Panel title={<span>Fattorizzazione <ILatex>{r`QR`}</ILatex></span>}>\n                    <p>\n                        Metodo che fornisce una <b>maggiore stabilità</b> a costo di una <b>maggiore complessità computazionale</b>.\n                    </p>\n                    <p>\n                        La matrice <ILatex>{r`A`}</ILatex> viene <i>fattorizzata</i> in due matrici, una <b>ortogonale</b> <ILatex>{r`Q`}</ILatex> e una <b>triangolare superiore</b> <ILatex>{r`R`}</ILatex>:\n                    </p>\n                    <PLatex>{r`A = Q \\cdot R`}</PLatex>\n                    <p>\n                        Le matrici si ottengono dal <b>prodotto delle trasformazioni di Householder</b> (che concatenate formano <ILatex>{r`Q`}</ILatex>) sulla matrice <ILatex>{r`A`}</ILatex> necessarie a trasformarla in una matrice triangolare superiore (<ILatex>{r`R`}</ILatex>).\n                    </p>\n                    <Example>\n                        C'è un bell'esempietto <Link href={\"https://web.archive.org/web/20200828003151/https://rpubs.com/aaronsc32/qr-decomposition-householder\"}>qui</Link>.\n                    </Example>\n                    <p>\n                        Una volta fattorizzata, il sistema si può risolvere con:\n                    </p>\n                    <PLatex>{r`\n                        \\begin{cases}\n                            y = Q^T \\cdot b\\\\\n                            R \\cdot x = y\n                        \\end{cases}\n                    `}</PLatex>\n                    <p>\n                        Questo metodo ha costo computazionale:\n                    </p>\n                    <PLatex>{r`{\\color{Yellow} O\\left(\\frac{2 \\cdot n^3}{3}\\right)} + 2 \\cdot O\\left(\\frac{n^2}{2}\\right)`}</PLatex>\n                </Panel>\n            </Section>\n            <Section title={\"Metodi iterativi\"}>\n                <Panel title={\"Forma generale\"}>\n                    <p>\n                        Se si pone che:\n                    </p>\n                    <PLatex>{r`\n                        \\begin{cases}\n                            G = I - M^{-1} \\cdot A\\\\\n                            c = M^{-1} \\cdot b\n                        \\end{cases}\n                    `}</PLatex>\n                    <p>\n                        Allora la formula generale di un sistema lineare può anche essere scritta in questo modo:\n                    </p>\n                    <PLatex>{r`x = G \\cdot x + c`}</PLatex>\n                    <p>\n                        È particolarmente utile perchè ci permette di definire un <b>algoritmo ricorsivo</b> che trovi <ILatex>{r`x`}</ILatex>:\n                    </p>\n                    <PLatex>{r`x_{(i+1)} = G \\cdot x_{(i)} + c`}</PLatex>\n                    <p>\n                        <ILatex>{r`G`}</ILatex> è il <b>metodo</b>, e in base ad esso cambiano stabilità e velocità di convergenza.\n                    </p>\n                    <p>\n                        Ponendo <ILatex>{r`A = M - N`}</ILatex>, la formula può essere scritta anche in questo modo:\n                    </p>\n                    <PLatex>{r`M \\cdot x_{(i+1)} = N \\cdot x_{(i)} + b`}</PLatex>\n                    <p>\n                        Possiamo ottenere alcuni metodi separando <ILatex>A</ILatex> in tre matrici:\n                    </p>\n                    <ul>\n                        <li>La parte diagonale <ILatex>{r`D`}</ILatex></li>\n                        <li>L'opposto del triangolo inferiore <ILatex>{r`E`}</ILatex></li>\n                        <li>L'opposto del triangolo superiore <ILatex>{r`F`}</ILatex></li>\n                    </ul>\n                    <PLatex>{r`A = D - E - F`}</PLatex>\n                </Panel>\n                <Panel title={\"Convergenza di un metodo\"}>\n                    <p>\n                        Un metodo è convergente se e solo se:\n                    </p>\n                    <PLatex>{r`\\rho (M) < 1`}</PLatex>\n                    <p>\n                        (dove <ILatex>{r`\\rho`}</ILatex> è il <b>raggio spettrale</b>, il massimo autovalore della matrice)\n                    </p>\n                    <p>\n                        Perchè un metodo sia convergente, è sufficiente che:\n                    </p>\n                    <PLatex>{r`\\| M \\| < 1`}</PLatex>\n                    <p>\n                        <Todo>TODO: l'algoritmo con tau per le condizioni di arresto</Todo>\n                    </p>\n                </Panel>\n            </Section>\n            <Section>\n                <Panel title={\"Metodo di Jacobi\"}>\n                    <p>\n                        Il metodo di Jacobi si ottiene ponendo:\n                    </p>\n                    <PLatex>{r`\n                        \\begin{cases}\n                            M = D\\\\\n                            N = E + F\n                        \\end{cases}\n                    `}</PLatex>\n                    <p>\n                        <u>Spostamenti simultanei</u>: Permette di ottenere ogni componente di <ILatex>{r`x`}</ILatex> indipendentemente dagli altri: è <b>parallelizzabile</b>.\n                    </p>\n                    <p>\n                        Se la matrice è <b>diagonale dominante</b>, allora il metodo di Jacobi <b>converge</b> sicuramente.\n                    </p>\n                </Panel>\n                <Panel title={\"Metodo di Gauss-Seidel\"}>\n                    <p>\n                        Il metodo di Gauss-Seidel si ottiene ponendo:\n                    </p>\n                    <PLatex>{r`\n                        \\begin{cases}\n                            M = D - E\\\\\n                            N = F\n                        \\end{cases}\n                    `}</PLatex>\n                    <p>\n                        Ha una velocità di convergenza <b>maggiore o uguale</b> rispetto al metodo di Jacobi.\n                    </p>\n                    <p>\n                        <u>Spostamenti successivi</u>: Non è parallelizzabile, perchè ogni componente <b>dipende da quelle calcolate in precedenza</b>.\n                    </p>\n                    <p>\n                        Se la matrice è <b>diagonale dominante</b>, allora il metodo di Gauss-Seidel <b>converge</b> sicuramente.\n                    </p>\n                </Panel>\n            </Section>\n        </Fragment>\n    )\n}\n","import Intro from \"./00_Intro\";\nimport SistemiLineari from \"./01_SistemiLineari\";\nimport ZeriDiFunzione from \"./02_ZeriDiFunzione\";\nimport Interpolazione from \"./03_Interpolazione\";\nimport InterpolazioneATratti from \"./04_InterpolazioneATratti\";\nimport ApprossimazioneDatiSperimentali from \"./05_ApprossimazioneDatiSperimentali\";\n\nconst r = String.raw;\n\n\nexport default function (props) {\n    return (\n        <div>\n            <h1>Calcolo Numerico</h1>\n            <Intro/>\n            <SistemiLineari/>\n            <ZeriDiFunzione/>\n            <Interpolazione/>\n            <InterpolazioneATratti/>\n            <ApprossimazioneDatiSperimentali/>\n        </div>\n    )\n}\n","import style from \"./00_Intro.less\"\nimport {ILatex, Panel, PLatex, Section, Timer} from \"bluelib\";\nimport Link from \"../../components/Link\";\nimport MenuList from \"../../components/MenuList\";\nimport Example from \"../../components/Example\";\nimport {Fragment} from \"preact\";\nimport {BoxColors} from \"bluelib/dist/index.modern\";\n\nconst r = String.raw;\n\n\nexport default function (props) {\n    return (\n        <Fragment>\n            <Section title={\"Esame\"}>\n                <Panel title={\"Contatti\"}>\n                    <ul>\n                        <li><Link href={\"mailto:silvia.bonettini@unimore.it\"}>Prof.ssa Silvia Bonettini</Link></li>\n                    </ul>\n                </Panel>\n                <Panel title={\"Orale\"}>\n                    <p>\n                        E' composto da:\n                    </p>\n                    <ul>\n                        <li>2 domande sugli argomenti teorici</li>\n                        <li>1 domanda di implementazione algoritmo in MATLAB</li>\n                    </ul>\n                </Panel>\n                <Panel title={\"Sessione autunnale\"}>\n                    <ol>\n                        <li><Timer to={\"2020-08-31 09:00\"}/></li>\n                        <li><Timer to={\"2020-09-14 09:00\"}/></li>\n                    </ol>\n                </Panel>\n            </Section>\n            <Section title={\"Informazioni\"}>\n                <Panel title={\"Ripasso di Algebra Lineare\"}>\n                    <p>\n                        Prima di iniziare a studiare Calcolo Numerico, potrebbe essere una buona idea ripassare un pochino Algebra Lineare:\n                    </p>\n                    <MenuList>\n                        <li>\n                            <a href={\"/calcolonumerico/ripassodialgebralineare\"}>Ripasso di Algebra Lineare</a> <small>(per studenti sperduti di Calcolo Numerico)</small>\n                        </li>\n                    </MenuList>\n                </Panel>\n                <Panel color={BoxColors.YELLOW} title={<span><b>Novità</b>: Anki</span>}>\n                    <p>\n                        Ho provato a fare un deck <Link href={\"https://apps.ankiweb.net/\"}>Anki</Link> con tutte le formule di Calcolo numerico.\n                    </p>\n                    <p>\n                        Sappiatemi dire com'è! <small>Io non l'ho usato moltissimo perchè ho studiato scrivendo questa pagina di Appuntiweb...</small>\n                    </p>\n                    <MenuList>\n                        <li><Link href={\"https://ryg.s3.fr-par.scw.cloud/builds/anki-decks/formule-di-calcolo-numerico.apkg\"}>Scarica il deck Anki</Link></li>\n                    </MenuList>\n                </Panel>\n            </Section>\n            <Section title={\"Algoritmi\"}>\n                <Panel title={\"Algoritmi numerici\"}>\n                    <p>\n                        Particolari algoritmi che hanno:\n                    </p>\n                    <ul>\n                        <li>numeri reali in input e output</li>\n                        <li>successioni delle quattro operazioni aritmetiche fondamentali come passi</li>\n                    </ul>\n                </Panel>\n            </Section>\n            <Section title={\"Errore di rappresentazione\"}>\n                <Panel title={\"Cos'è?\"}>\n                    <p>\n                        Con i numeri floating point può capitare che un certo numero <ILatex>{r`\\alpha`}</ILatex> non\n                        sia rappresentato correttamente.\n                    </p>\n                    <p>\n                        In tal caso, il numero si indica con <ILatex>{r`\\alpha^\\star`}</ILatex>.\n                    </p>\n                </Panel>\n            </Section>\n            <Section>\n                <Panel title={\"Errore assoluto\"}>\n                    <p>\n                        È la differenza tra il numero desiderato e il numero rappresentato:\n                    </p>\n                    <PLatex>{r`E_a = \\left | \\alpha - \\alpha^\\star \\right |`}</PLatex>\n                </Panel>\n                <Panel title={\"Errore relativo\"}>\n                    <p>\n                        Indica quanto il numero rappresentato differisce dal numero desiderato:\n                    </p>\n                    <PLatex>{r`\\forall \\alpha \\neq 0, E_r = \\frac{E_a}{\\left | \\alpha \\right |}`}</PLatex>\n                </Panel>\n            </Section>\n            <Section>\n                <Panel title={\"Troncamento\"}>\n                    <p>\n                        Metodo con cui gestire gli <b>underflow floating point</b>: le cifre meno significative\n                        vengono <b>rimosse</b>.\n                    </p>\n                    <Example>\n                        <pre>\n                            1.00  →  1.0<br/>\n                            1.01  →  1.0<br/>\n                            1.10  →  1.1<br/>\n                            1.11  →  1.1\n                        </pre>\n                    </Example>\n                </Panel>\n                <Panel title={\"Arrotondamento\"}>\n                    <p>\n                        Metodo con cui gestire gli <b>underflow floating point</b>: se la cifra più significativa di\n                        quelle che devono essere rimosse è 1, allora <b>aumenta di 1</b> anche quella meno signficativa\n                        che viene tenuta.\n                    </p>\n                    <Example>\n                        <pre>\n                            1.00  →  1.0<br/>\n                            1.01  →  1.0<br/>\n                            1.10  →  1.1<br/>\n                            1.11  → 10.\n                        </pre>\n                    </Example>\n                </Panel>\n            </Section>\n            <Section>\n                <Panel title={\"Precisione di macchina\"}>\n                    <p>\n                        Un numero reale rappresentato in <b>virgola mobile</b> ha un <b>errore relativo</b> minore o uguale alla <i>precisione\n                        di macchina</i>:\n                    </p>\n                    <p>\n                        <ILatex>{r`E_r \\leq k \\cdot \\beta^{1-t}`}</ILatex>\n                    </p>\n                    <ul>\n                        <li>\n                            <ILatex>\\beta</ILatex> è uguale alla base utilizzata (solitamente 2).\n                        </li>\n                        <li>\n                            <ILatex>t</ILatex> è uguale al numero di cifre della mantissa.\n                        </li>\n                        <li>\n                            <ILatex>k</ILatex> è uguale a <ILatex>1</ILatex> se il numero viene rappresentato per\n                            troncamento oppure a <ILatex>{r`\\frac{1}{2}`}</ILatex> se viene rappresentato per\n                            arrotondamento.\n                        </li>\n                    </ul>\n                </Panel>\n                <Panel title={\"La funzione fl\"}>\n                    <p>\n                        Associa un valore reale al suo <b>corrispondente valore floating point</b>, utilizzando uno dei\n                        due metodi di gestione dell'undeflow.\n                    </p>\n                    <PLatex>{r`fl(x) = (x)(1 + \\epsilon_x)`}</PLatex>\n                    <Example>\n                        Indica che un valore è soggetto alla precisione di macchina.\n                        <PLatex>{r`fl(1.11) = 1.1`}</PLatex>\n                    </Example>\n                </Panel>\n            </Section>\n            <Section>\n                <Panel title={\"Un nuovo insieme\"}>\n                    <p>\n                        L'insieme <ILatex>{r`\\mathbb{F}`}</ILatex> è il sottoinsieme dei numeri reali rappresentabili in\n                        floating point dalla macchina che stiamo usando.\n                    </p>\n                    <p>\n                        Operazioni tra elementi di <ILatex>{r`\\mathbb{F}`}</ILatex> producono risultati\n                        in <ILatex>{r`\\mathbb{R}`}</ILatex>, che però decaderanno nuovamente a elementi\n                        di <ILatex>{r`\\mathbb{F}`}</ILatex>, perdendo informazioni.\n                    </p>\n                    <p>\n                        Il teorema della precisione di macchina si applica quindi anche ai risultati delle operazioni.\n                    </p>\n                </Panel>\n                <Panel title={\"Caratteristiche delle operazioni di macchina\"}>\n                    <ul>\n                        <li>Hanno <b>più elementi neutri</b>.</li>\n                        <li>Un numero ha <b>più opposti</b>.</li>\n                        <li><b>Non</b> sono associative.</li>\n                        <li><b>Non</b> sono distributive.</li>\n                        <li><b>Non</b> vale la legge di annullamento del prodotto.</li>\n                    </ul>\n                </Panel>\n            </Section>\n            <Section title={\"Errori nelle operazioni di macchina\"}>\n                <Panel title={\"Errore inerente\"}>\n                    <p>\n                        Errore derivato da underflow sui <b>dati</b>.\n                    </p>\n                    <p>\n                        Si indica con <ILatex>{r`\\epsilon_{nome\\_var}`}</ILatex>.\n                    </p>\n                    <Example>\n                        L'errore sulla variabile <ILatex>x</ILatex> si indica con <ILatex>{r`\\epsilon_{x}`}</ILatex>.\n                    </Example>\n                </Panel>\n                <Panel title={\"Errore algoritmico\"}>\n                    <p>\n                        Errore derivato da underflow durante l'<b>esecuzione dell'algoritmo</b>.\n                    </p>\n                    <p>\n                        Si indica con <ILatex>{r`\\epsilon_{num\\_passo}`}</ILatex>.\n                    </p>\n                    <Example>\n                        L'errore al primo passo dell'algoritmo si indica con <ILatex>{r`\\epsilon_{1}`}</ILatex>.\n                    </Example>\n                </Panel>\n            </Section>\n            <Section>\n                <Panel title={\"Condizionamento\"}>\n                    <p>\n                        Sensibilità di un problema all'<b>errore inerente</b>.\n                    </p>\n                    <Example>\n                        <ILatex>{r`y = \\frac{1}{x}`}</ILatex> è mal condizionato intorno allo 0 e ben condizionato\n                        lontano dallo 0.\n                    </Example>\n                </Panel>\n                <Panel title={\"Stabilità\"}>\n                    <p>\n                        Sensibilità di un problema all'<b>errore algoritmico</b>.\n                    </p>\n                    <Example>\n                        <p>\n                            Cerchiamo un algoritmo che risolva <ILatex>{r`2x^\\star = 4`}</ILatex>.\n                        </p>\n                        <p>\n                            Calcolare prima <ILatex>{r`t = fl \\left( \\frac{1}{4} \\right)`}</ILatex> e\n                            poi <ILatex>{r`x = fl ( 2 \\cdot t )`}</ILatex> porta a una perdita di precisione.\n                        </p>\n                        <p>\n                            Calcolare direttamente <ILatex>{r`x = fl \\left( \\frac{2}{4} \\right)`}</ILatex> non ha alcuna\n                            perdita di precisione e rende l'algoritmo <b>più stabile</b> del precedente.\n                        </p>\n                    </Example>\n                </Panel>\n            </Section>\n            <Section>\n                <Panel title={\"Indice di condizionamento\"}>\n                    <p>\n                        È il coefficiente di proporzionalità tra i dati e l'<b>errore inerente</b>.\n                    </p>\n                    <p>\n                        Essendo sempre maggiore di uno, si può dire che sia un coefficiente di amplificazione.\n                    </p>\n                    <p>\n                        Minore è l'indice di condizionamento, meglio condizionato è un problema.\n                    </p>\n                </Panel>\n                <Panel title={\"Indice algoritmico\"}>\n                    <p>\n                        È il coefficiente di proporzionalità tra i dati e l'<b>errore algoritmico</b>.\n                    </p>\n                    <p>\n                        Essendo sempre maggiore di uno, si può dire che sia un coefficiente di amplificazione.\n                    </p>\n                </Panel>\n            </Section>\n        </Fragment>\n    )\n}\n","import style from \"./05_ApprossimazioneDatiSperimentali.less\";\nimport {Fragment} from \"preact\";\nimport {Section, Panel, ILatex, BLatex, PLatex} from \"bluelib\";\nimport Example from \"../../components/Example\";\n\nconst r = String.raw;\n\n\nexport default function (props) {\n    return (\n        <Fragment>\n            <Section title={\"Problema: Approssimazione di dati sperimentali\"}>\n                <Panel title={\"Perchè?\"}>\n                    <p>\n                        Interpolare dati sperimentali non fornisce quasi mai un modello del fenomeno.\n                    </p>\n                    <p>\n                        Vogliamo costruire una <b>funzione di regressione</b> che, dati molti più dati del grado della funzione, minimizzi il quadrato della distanza tra i punti sperimentali e i punti della funzione di regressione.\n                    </p>\n                    <p>\n                        Denominiamo:\n                    </p>\n                    <ul>\n                        <li><ILatex>{r`{\\color{Orange} f}`}</ILatex>: la <b>funzione \"effettiva\"</b> del fenomeno</li>\n                        <li><ILatex>{r`{\\color{Yellow} q}`}</ILatex>: la <b>funzione di regressione</b> che costruiamo per approssimarlo</li>\n                        <li><ILatex>{r`{\\color{Red} Q }`}</ILatex>: la <b>funzione \"errore di regressione\"</b> da minimizzare</li>\n                        <li><ILatex>{r`(\\ x_i, f(x_i)\\ )`}</ILatex>: i <b>punti sperimentali</b></li>\n                    </ul>\n                    <p>\n                        L'obiettivo è minimizzare l'<b>errore di approssimazione</b> <ILatex>{r`Q`}</ILatex>, ovvero:\n                    </p>\n                    <PLatex>{r`\\min {\\color{Red} Q } = \\sum_{i = 1}^m (\\ {\\color{Yellow} q(x_i)} - {\\color{Orange} f(x_i)}\\ )^2 `}</PLatex>\n                </Panel>\n            </Section>\n            <Section>\n                <Panel title={\"Regressione lineare\"}>\n                    <p>\n                        Trova la <b>retta</b> <ILatex>{r`{\\color{Yellow} q}`}</ILatex> che meglio approssima tutti gli <ILatex>{r`m`}</ILatex> dati sperimentali.\n                    </p>\n                    <p>\n                        Essendo una retta, avrà <b>due parametri</b>: il termine noto <ILatex>{r`a_0`}</ILatex>, e la pendenza <ILatex>{`a_1`}</ILatex>.\n                    </p>\n                    <PLatex>{r`{\\color{Yellow} q(x) } = a_0 + a_1 \\cdot {\\color{Green} x}`}</PLatex>\n                    <p>\n                        L'errore da minimizzare per ricavare i parametri sarà:\n                    </p>\n                    <PLatex>{r`\n                        \\min {\\color{Red} Q } = \\sum_{i = 1}^m ( {\\color{Yellow} a_0 + a_1 \\cdot x_i} - {\\color{Orange} f(x_i)} )^2\n                    `}</PLatex>\n                </Panel>\n                <Panel title={\"Regressione lineare matriciale\"}>\n                    <p>\n                        Possiamo costruire una <b>matrice di regressione</b> <ILatex>{r`A`}</ILatex> contenente tutti i <b>punti sperimentali</b>:\n                    </p>\n                    <PLatex>{r`\n                        A =\n                        \\begin{pmatrix}\n                            1 & x_1\\\\\\\\\n                            1 & x_2\\\\\\\\\n                            \\vdots & \\vdots\\\\\\\\\n                            1 & x_m\n                        \\end{pmatrix}\n                    `}</PLatex>\n                    <p>\n                        Inoltre, se costruiamo il <b>vettore dei parametri</b> <ILatex>{r`\\alpha`}</ILatex>:\n                    </p>\n                    <PLatex>{r`\n                        \\alpha =\n                        \\begin{pmatrix}\n                            a_0\\\\\\\\\n                            a_1\n                        \\end{pmatrix}\n                    `}</PLatex>\n                    <p>\n                        Avremo che:\n                    </p>\n                    <PLatex>{r`{\\color{Yellow} q(x) } = A \\cdot \\alpha`}</PLatex>\n                    <p>\n                        Inoltre, potremo calcolare l'errore attraverso la norma:\n                    </p>\n                    <PLatex>{r`{\\color{Red} Q } = \\| A \\cdot \\alpha - y \\|^2`}</PLatex>\n                </Panel>\n            </Section>\n            <Section>\n                <Panel title={\"Regressione polinomiale\"}>\n                    <p>\n                        Trova il <b>polinomio</b> <ILatex>{r`{\\color{Yellow} q}`}</ILatex> di grado <ILatex>{r`n-1`}</ILatex> che meglio approssima tutti gli <ILatex>{r`m`}</ILatex> dati sperimentali.\n                    </p>\n                    <p>\n                        Essendo un polinomio di grado <ILatex>{r`n-1`}</ILatex>, avrà <ILatex>{r`n`}</ILatex> parametri.\n                    </p>\n                    <PLatex>{r`{\\color{Yellow} q(x) } = a_0 + a_1 \\cdot {\\color{Green} x} + a_2 \\cdot {\\color{Green} x^2} +\\ \\dots \\ + a_{n-1} \\cdot {\\color{Green} x^{n-1}`}</PLatex>\n                    <Example>\n                        <p>\n                            La regressione lineare è un caso particolare di regressione generale in cui i parametri sono 2!\n                        </p>\n                    </Example>\n                    <p>\n                        L'errore da minimizzare per ricavare i parametri sarà:\n                    </p>\n                    <PLatex>{r`\n                        \\min {\\color{Red} Q} = \\sum_{i = 1}^m ( {\\color{Yellow} a_0 + a_1 \\cdot x_i + a_2 \\cdot x_i^2 +\\ \\dots \\ + a_{n-1} \\cdot x_i^{n-1}} - {\\color{Orange} y_i} )^2\n                    `}</PLatex>\n                </Panel>\n                <Panel title={\"Regressione polinomiale matriciale\"}>\n                    <p>\n                        Possiamo costruire una <b>matrice di regressione</b> <ILatex>{r`A`}</ILatex> contenente tutti i <b>punti sperimentali</b> a tutti i gradi del polinomio:\n                    </p>\n                    <PLatex>{r`\n                        A =\n                        \\begin{pmatrix}\n                            1 & x_1 & x_1^2 & \\dots & x_1^{n-1} \\\\\\\\\n                            1 & x_2 & x_2^2 & \\dots & x_2^{n-1} \\\\\\\\\n                            \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\\\\\\n                            1 & x_m & x_m^2 & \\dots & x_m^{n-1}\n                        \\end{pmatrix}\n                    `}</PLatex>\n                    <p>\n                        Inoltre, se costruiamo il <b>vettore dei parametri</b> <ILatex>{r`\\alpha`}</ILatex>:\n                    </p>\n                    <PLatex>{r`\n                        \\alpha =\n                        \\begin{pmatrix}\n                            a_0\\\\\\\\\n                            a_1\\\\\\\\\n                            \\vdots\\\\\\\\\n                            a_{n-1}\n                        \\end{pmatrix}\n                    `}</PLatex>\n                    <p>\n                        Avremo che:\n                    </p>\n                    <PLatex>{r`{\\color{Yellow} q(x) } = A \\cdot \\alpha`}</PLatex>\n                    <p>\n                        Inoltre, potremo calcolare l'errore attraverso la norma:\n                    </p>\n                    <PLatex>{r`{\\color{Red} Q } = \\| A \\cdot \\alpha - y \\|^2`}</PLatex>\n                    <Example>\n                        Normalmente, i dati sono molti di più, ma se il numero di parametri <ILatex>{r`n`}</ILatex> fosse uguale al numero di dati <ILatex>{r`m`}</ILatex>, allora si otterrebbe il <b>polinomio di interpolazione</b>!\n                    </Example>\n                </Panel>\n            </Section>\n            <Section>\n                <Panel title={\"Regressione generale\"}>\n                    <p>\n                        Trova i <b>coefficienti della combinazione lineare</b> <ILatex>{r`{\\color{Yellow} q}`}</ILatex> che meglio approssima tutti gli <ILatex>{r`m`}</ILatex> dati sperimentali.\n                    </p>\n                    <PLatex>{r`{\\color{Yellow} q(x) } = a_0 \\cdot {\\color{Green} \\phi_0 (x)} + a_1 \\cdot {\\color{Green} \\phi_1 (x)} + \\dots + a_2 \\cdot {\\color{Green} \\phi_2 (x)} +\\ \\dots\\ + a_{n-1} \\cdot {\\color{Green} \\phi_{n-1} (x)}`}</PLatex>\n                    <Example>\n                        <p>\n                            La regressione polinomiale è un caso particolare di regressione generale in cui:\n                        </p>\n                        <PLatex>{r`{\\color{Green} \\phi_{n} (x)} = x^n`}</PLatex>\n                    </Example>\n                    <p>\n                        L'errore da minimizzare per ricavare i parametri sarà:\n                    </p>\n                    <PLatex>{r`\n                        \\min {\\color{Red} Q } = \\sum_{i = 1}^m ( {\\color{Yellow} a_0 \\cdot \\phi_0 (x) + a_1 \\cdot \\phi_1 (x) + \\dots + a_2 \\cdot \\phi_2 (x) +\\ \\dots\\ + a_{n-1} \\cdot \\phi_{n-1} (x)} - {\\color{Orange} f(x_i)} )^2\n                    `}</PLatex>\n                </Panel>\n                <Panel title={\"Regressione polinomiale generale\"}>\n                    <p>\n                        Possiamo costruire una <b>matrice di regressione</b> <ILatex>{r`A`}</ILatex> contenente tutti i <b>punti sperimentali</b> a tutti i gradi del polinomio:\n                    </p>\n                    <PLatex>{r`\n                        A =\n                        \\begin{pmatrix}\n                            \\phi_0(x_1) & \\phi_1(x_1) & \\phi_2(x_1) & \\dots & \\phi_{n_1}(x_1) \\\\\\\\\n                            \\phi_0(x_2) & \\phi_1(x_2) & \\phi_2(x_2) & \\dots & \\phi_{n-1}(x_2) \\\\\\\\\n                            \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\\\\\\n                            \\phi_0(x_m) & \\phi_1(x_m) & \\phi_2(x_m) & \\dots & \\phi_{n-1}(x_m)\n                        \\end{pmatrix}\n                    `}</PLatex>\n                    <p>\n                        Inoltre, se costruiamo il <b>vettore dei parametri</b> <ILatex>{r`\\alpha`}</ILatex>:\n                    </p>\n                    <PLatex>{r`\n                        \\alpha =\n                        \\begin{pmatrix}\n                            a_0\\\\\\\\\n                            a_1\\\\\\\\\n                            \\vdots\\\\\\\\\n                            a_{n-1}\n                        \\end{pmatrix}\n                    `}</PLatex>\n                    <p>\n                        Avremo che:\n                    </p>\n                    <PLatex>{r`{\\color{Yellow} q(x) } = A \\cdot \\alpha`}</PLatex>\n                    <p>\n                        Inoltre, potremo calcolare l'errore attraverso la norma:\n                    </p>\n                    <PLatex>{r`{\\color{Red} Q } = \\| A \\cdot \\alpha - y \\|^2`}</PLatex>\n                </Panel>\n            </Section>\n            <Section title={\"Trovare i parametri\"}>\n                <Panel title={\"Caso non degenere\"}>\n                    <p>\n                        Caso che prevede che le colonne di <ILatex>{r`A`}</ILatex> siano <b>linearmente indipendenti</b>.\n                    </p>\n                    <p>\n                        La soluzione <b>esiste</b> sempre, ed è <b>unica</b>.\n                    </p>\n                    <p>\n                        Per trovarla:\n                    </p>\n                    <ul>\n                        <li>Fattorizziamo <ILatex>{r`A = Q \\cdot \\begin{pmatrix} R\\\\ 0 \\end{pmatrix}`}</ILatex>.</li>\n                        <li>Calcoliamo <ILatex>{r`w = Q^T \\cdot y`}</ILatex>.</li>\n                        <li>Teniamo solo i primi <ILatex>n</ILatex> valori di <ILatex>{r`w`}</ILatex> e mettiamoli in <ILatex>{r`w_1`}</ILatex>.</li>\n                        <li>Calcoliamo <ILatex>{r`R \\cdot \\alpha = w_1`}</ILatex>.</li>\n                    </ul>\n                </Panel>\n                <Panel title={\"Caso generale\"}>\n                    <p>\n                        Caso che non preclude alcuna composizione di <ILatex>{r`A`}</ILatex>.\n                    </p>\n                    <p>\n                        Ci sono <b>infinite</b> soluzioni, con <ILatex>{`n-k`}</ILatex> gradi di libertà.\n                    </p>\n                    <p>\n                        Si cerca sempre di trovare la <i>soluzione di norma minima</i>, che, se <ILatex>{r`k \\leq n \\leq m`}</ILatex>, allora è <b>unica</b>.\n                    </p>\n                    <p>\n                        Per trovarla:\n                    </p>\n                    <ul>\n                        <li>Fattorizziamo <ILatex>{r`A = U \\cdot \\Sigma \\cdot V^T`}</ILatex> con la <i>fattorizzazione SVD</i></li>\n                        <li>Calcoliamo <ILatex>{r`\\zeta = U^T \\cdot y`}</ILatex></li>\n                        <li>\n                            <p>\n                                Calcoliamo:\n                            </p>\n                            <PLatex>{r`\n                            \\gamma =\n                            \\begin{pmatrix}\n                                \\frac{z_1}{\\sigma_1}\\\\\\\\\n                                \\frac{z_2}{\\sigma_2}\\\\\\\\\n                                \\vdots\\\\\\\\\n                                \\frac{z_{k-1}}{\\sigma_{k-1}}\\\\\\\\\n                                \\frac{z_k}{\\sigma_k}\\\\\\\\\n                                0\\\\\\\\\n                                0\\\\\\\\\n                                \\vdots\\\\\\\\\n                                0\n                            \\end{pmatrix}                            \n                            `}</PLatex>\n                        </li>\n                        <li>Calcoliamo <ILatex>{r`\\alpha = V \\cdot \\gamma`}</ILatex></li>\n                    </ul>\n                    <Example>\n                        Gli zeri nella <ILatex>{r`\\gamma`}</ILatex> sono i gradi di libertà, sono zero in modo che essi diano la norma minima.\n                    </Example>\n                </Panel>\n            </Section>\n        </Fragment>\n    )\n}\n"],"sourceRoot":""}